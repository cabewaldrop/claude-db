{"id":"cdb-034","title":"Format query plan display","description":"## Problem\nQuery plan output needs clear, readable formatting.\n\n## Solution\nTemplate partial that renders plan details visually.\n\n## Implementation\n\n```html\n{{/* templates/partials/plan.html */}}\n\u003cdiv class=\"query-plan\"\u003e\n    \u003ch3\u003eQuery Plan\u003c/h3\u003e\n    \n    \u003cdiv class=\"plan-summary\"\u003e\n        \u003cdiv class=\"plan-type {{.Plan.Type | lower}}\"\u003e\n            {{.Plan.Type}}\n        \u003c/div\u003e\n        \n        {{if .Plan.Table}}\n        \u003cdiv class=\"plan-detail\"\u003e\n            \u003cspan class=\"label\"\u003eTable:\u003c/span\u003e\n            \u003cspan class=\"value\"\u003e{{.Plan.Table}}\u003c/span\u003e\n        \u003c/div\u003e\n        {{end}}\n        \n        {{if .Plan.Index}}\n        \u003cdiv class=\"plan-detail\"\u003e\n            \u003cspan class=\"label\"\u003eIndex:\u003c/span\u003e\n            \u003cspan class=\"value\"\u003e{{.Plan.Index}}\u003c/span\u003e\n        \u003c/div\u003e\n        {{end}}\n        \n        {{if .Plan.EstimatedRows}}\n        \u003cdiv class=\"plan-detail\"\u003e\n            \u003cspan class=\"label\"\u003eEst. Rows:\u003c/span\u003e\n            \u003cspan class=\"value\"\u003e{{.Plan.EstimatedRows}}\u003c/span\u003e\n        \u003c/div\u003e\n        {{end}}\n    \u003c/div\u003e\n    \n    {{if .Plan.Predicates}}\n    \u003cdiv class=\"plan-predicates\"\u003e\n        \u003ch4\u003ePredicates\u003c/h4\u003e\n        \u003cul\u003e\n            {{range .Plan.Predicates}}\n            \u003cli\u003e{{.}}\u003c/li\u003e\n            {{end}}\n        \u003c/ul\u003e\n    \u003c/div\u003e\n    {{end}}\n    \n    \u003cdetails class=\"plan-raw\"\u003e\n        \u003csummary\u003eRaw Output\u003c/summary\u003e\n        \u003cpre\u003e{{.RawOutput}}\u003c/pre\u003e\n    \u003c/details\u003e\n\u003c/div\u003e\n```\n\nCSS for plan display:\n```css\n.query-plan {\n    background: #f8f9fa;\n    border: 1px solid #dee2e6;\n    border-radius: 4px;\n    padding: 1rem;\n    margin: 1rem 0;\n}\n\n.plan-type {\n    display: inline-block;\n    padding: 0.25rem 0.75rem;\n    border-radius: 4px;\n    font-weight: bold;\n    margin-bottom: 0.5rem;\n}\n\n.plan-type.tablescan {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.plan-type.indexscan {\n    background: #d4edda;\n    color: #155724;\n}\n\n.plan-type.indexrangescan {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.plan-detail {\n    display: flex;\n    gap: 0.5rem;\n    margin: 0.25rem 0;\n}\n\n.plan-detail .label {\n    font-weight: 500;\n    color: #6c757d;\n}\n\n.plan-raw pre {\n    background: #e9ecef;\n    padding: 0.5rem;\n    overflow-x: auto;\n}\n```\n\n## Files to Create\n- internal/web/templates/partials/plan.html\n- internal/web/static/style.css (add plan styles)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| TableScan | Yellow/warning color (full scan) |\n| IndexScan | Green color (efficient) |\n| No estimated rows | Dont show estimate field |\n| Very long predicate | Wrap or truncate gracefully |\n| Plan parsing failed | Show raw output only |\n| Multiple plans (UNION) | Show each plan in sequence |\n\n## Test Scenarios\n\n```go\nfunc TestPlanTemplateRenders(t *testing.T) {\n    plan := \u0026QueryPlan{\n        Type:          \"IndexScan\",\n        Table:         \"users\",\n        Index:         \"idx_email\",\n        EstimatedRows: 1,\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/plan.html\", map[string]interface{}{\n        \"Plan\":      plan,\n        \"RawOutput\": \"Plan: IndexScan on users using idx_email\",\n    })\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"IndexScan\")\n    assert.Contains(t, html, \"idx_email\")\n    assert.Contains(t, html, \"indexscan\") // CSS class\n}\n\nfunc TestPlanTemplateTableScan(t *testing.T) {\n    plan := \u0026QueryPlan{\n        Type:  \"TableScan\",\n        Table: \"users\",\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/plan.html\", map[string]interface{}{\n        \"Plan\": plan,\n    })\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"TableScan\")\n    assert.Contains(t, html, \"tablescan\") // Warning CSS class\n    assert.NotContains(t, html, \"Index:\")\n}\n\nfunc TestPlanTemplateFallback(t *testing.T) {\n    // When plan is nil, show raw output only\n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/plan.html\", map[string]interface{}{\n        \"Plan\":      nil,\n        \"RawOutput\": \"Unparseable plan output here\",\n    })\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"Unparseable plan\")\n}\n```\n\n## Definition of Done\n- [ ] partials/plan.html template created\n- [ ] Plan type shown with color coding\n- [ ] Table name displayed\n- [ ] Index name displayed when used\n- [ ] Estimated rows shown when available\n- [ ] Predicates listed\n- [ ] Raw output in collapsible details\n- [ ] CSS styles for plan visualization\n- [ ] TestPlanTemplateRenders passes\n- [ ] TestPlanTemplateTableScan passes\n- [ ] TestPlanTemplateFallback passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"rictus","created_at":"2026-01-07T16:55:49.249107-07:00","created_by":"mayor","updated_at":"2026-01-07T17:31:39.274693-07:00","closed_at":"2026-01-07T17:31:39.274693-07:00","close_reason":"Implemented query plan display template with HTML/CSS and tests. All tests pass."}
{"id":"cdb-0bf","title":"Session ended: gt-claudedb-dag","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:40:47.503742-07:00","created_by":"claudedb/polecats/dag","updated_at":"2026-01-07T14:40:47.503742-07:00"}
{"id":"cdb-0gq","title":"Secondary index support (CREATE INDEX)","description":"Add support for creating and using secondary indexes on non-PK columns.\n\n## Current State\n- Only primary key has an index\n- README lists 'Indexes beyond primary key' as a limitation\n\n## Implementation\n1. Add CREATE INDEX statement to parser\n2. Extend Table struct with indexes map[string]*BTree\n3. Maintain secondary indexes on INSERT/UPDATE/DELETE\n4. Query planner selects best index for WHERE clause\n\n## Syntax\n```sql\nCREATE INDEX users_age ON users(age);\nSELECT * FROM users WHERE age \u003e 30;  -- Uses index\n```\n\n## Files\n- internal/sql/parser/parser.go (new statement type)\n- internal/sql/ast/ast.go (CreateIndexStatement)\n- internal/table/table.go (multiple index support)\n- internal/sql/executor/executor.go (CREATE INDEX execution)\n- internal/sql/planner/ (index selection)\n\n## Acceptance Criteria\n- CREATE INDEX syntax works\n- Secondary indexes maintained on writes\n- Planner can choose secondary index for queries","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T12:19:05.789451-07:00","created_by":"mayor","updated_at":"2026-01-07T14:05:19.910546-07:00","closed_at":"2026-01-07T12:21:32.935096-07:00","close_reason":"Superseded by existing claude-db-xsr (Support secondary indexes) which has full implementation plan including catalog changes, DML maintenance, and persistence","dependencies":[{"issue_id":"cdb-0gq","depends_on_id":"cdb-2tp","type":"blocks","created_at":"2026-01-07T12:19:19.610572-07:00","created_by":"mayor"}]}
{"id":"cdb-0he","title":"Merge: cheedo-mk4ls9je","description":"branch: polecat/cheedo-mk4ls9je\ntarget: main\nsource_issue: cheedo-mk4ls9je\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-cheedo\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:29:43.685474-07:00","created_by":"claudedb/polecats/cheedo","updated_at":"2026-01-07T17:29:43.685474-07:00"}
{"id":"cdb-0mg","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:21:29.85376-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T14:21:29.85376-07:00"}
{"id":"cdb-0rc","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:44:15.11934-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T16:44:15.11934-07:00"}
{"id":"cdb-1f7","title":"Update row interface","description":"## Problem\nUsers need to edit existing rows without writing UPDATE statements.\n\n## Solution\nEdit form/modal loaded via HTMX when clicking edit button.\n\n## Implementation\n\n```html\n{{/* templates/partials/edit_row.html */}}\n\u003cdiv class=\"edit-modal-content\"\u003e\n    \u003ch3\u003eEdit Row\u003c/h3\u003e\n    \n    \u003cform hx-put=\"/tables/{{.Table}}/{{.PrimaryKey}}\" \n          hx-target=\"#result\"\n          hx-swap=\"outerHTML\"\u003e\n        \n        {{range .Columns}}\n        \u003cdiv class=\"form-group\"\u003e\n            \u003clabel for=\"edit-{{.Name}}\"\u003e{{.Name}}\u003c/label\u003e\n            \n            {{if .IsPrimaryKey}}\n            \u003cinput type=\"text\" id=\"edit-{{.Name}}\" value=\"{{.Value}}\" disabled\u003e\n            \u003cinput type=\"hidden\" name=\"{{.Name}}\" value=\"{{.Value}}\"\u003e\n            {{else if eq .Type \"TEXT\"}}\n            \u003ctextarea id=\"edit-{{.Name}}\" name=\"{{.Name}}\"\n                      {{if .NotNull}}required{{end}}\u003e{{.Value}}\u003c/textarea\u003e\n            {{else}}\n            \u003cinput type=\"text\" id=\"edit-{{.Name}}\" name=\"{{.Name}}\" \n                   value=\"{{.Value}}\"\n                   {{if .NotNull}}required{{end}}\u003e\n            {{end}}\n        \u003c/div\u003e\n        {{end}}\n        \n        \u003cdiv class=\"form-actions\"\u003e\n            \u003cbutton type=\"submit\" class=\"btn-primary\"\u003eSave\u003c/button\u003e\n            \u003cbutton type=\"button\" onclick=\"closeModal()\" class=\"btn\"\u003eCancel\u003c/button\u003e\n        \u003c/div\u003e\n    \u003c/form\u003e\n\u003c/div\u003e\n```\n\n```go\nfunc (s *Server) handleGetEditRow(w http.ResponseWriter, r *http.Request) {\n    tableName := chi.URLParam(r, \"name\")\n    pkValue := chi.URLParam(r, \"pk\")\n    exec := GetExecutor(r)\n    \n    schema, err := exec.GetTableSchema(tableName)\n    if err != nil {\n        http.Error(w, \"Table not found\", 404)\n        return\n    }\n    \n    // Find primary key column\n    pkCol := \"\"\n    for _, col := range schema.Columns {\n        if col.IsPrimaryKey {\n            pkCol = col.Name\n            break\n        }\n    }\n    if pkCol == \"\" {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Table has no primary key - cannot edit rows\",\n        })\n        return\n    }\n    \n    // Get current row data\n    query := fmt.Sprintf(\"SELECT * FROM %s WHERE %s = %s\", tableName, pkCol, pkValue)\n    result, err := exec.Execute(query)\n    if err != nil || len(result.Rows) == 0 {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Row not found\",\n        })\n        return\n    }\n    \n    // Build column data with current values\n    var columns []EditColumn\n    for i, col := range schema.Columns {\n        columns = append(columns, EditColumn{\n            Name:         col.Name,\n            Type:         col.Type.String(),\n            Value:        fmt.Sprintf(\"%v\", result.Rows[0][i]),\n            IsPrimaryKey: col.IsPrimaryKey,\n            NotNull:      col.NotNull,\n        })\n    }\n    \n    renderTemplate(w, \"partials/edit_row.html\", map[string]interface{}{\n        \"Table\":      tableName,\n        \"PrimaryKey\": pkValue,\n        \"Columns\":    columns,\n    })\n}\n\nfunc (s *Server) handleUpdateRow(w http.ResponseWriter, r *http.Request) {\n    tableName := chi.URLParam(r, \"name\")\n    pkValue := chi.URLParam(r, \"pk\")\n    exec := GetExecutor(r)\n    \n    schema, _ := exec.GetTableSchema(tableName)\n    pkCol := getPrimaryKeyColumn(schema)\n    \n    // Build SET clause\n    var sets []string\n    for _, col := range schema.Columns {\n        if col.IsPrimaryKey {\n            continue // Dont update PK\n        }\n        value := r.FormValue(col.Name)\n        if col.Type == \"TEXT\" {\n            sets = append(sets, fmt.Sprintf(\"%s = '%s'\", col.Name, escapeSQL(value)))\n        } else if value == \"\" {\n            sets = append(sets, fmt.Sprintf(\"%s = NULL\", col.Name))\n        } else {\n            sets = append(sets, fmt.Sprintf(\"%s = %s\", col.Name, value))\n        }\n    }\n    \n    sql := fmt.Sprintf(\"UPDATE %s SET %s WHERE %s = %s\",\n        tableName, strings.Join(sets, \", \"), pkCol, pkValue)\n    \n    _, err := exec.Execute(sql)\n    if err != nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": err.Error(),\n        })\n        return\n    }\n    \n    renderTemplate(w, \"partials/success.html\", map[string]string{\n        \"Message\": \"Row updated\",\n    })\n}\n```\n\n## Files to Create\n- internal/web/templates/partials/edit_row.html\n- internal/web/handlers.go (handleGetEditRow, handleUpdateRow)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Table without primary key | Show error \"cannot edit - no PK\" |\n| Row deleted while editing | Error on save \"row not found\" |\n| Concurrent edit conflict | No locking - last write wins |\n| Update violates constraint | SQL error displayed |\n| NULL to value | UPDATE col = value |\n| Value to NULL | UPDATE col = NULL |\n| Editing primary key | Disabled - PK shown but not editable |\n\n## Test Scenarios\n\n```go\nfunc TestEditRowFormLoads(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    exec.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/users/edit/1\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"Edit Row\")\n    assert.Contains(t, html, \"Alice\")\n    assert.Contains(t, html, \"disabled\") // PK field\n}\n\nfunc TestUpdateRowSuccess(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    exec.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    req, _ := http.NewRequest(http.MethodPut, ts.URL+\"/tables/users/1\", \n        strings.NewReader(\"name=Bob\"))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    resp, err := http.DefaultClient.Do(req)\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    // Verify update\n    result, _ := exec.Execute(\"SELECT name FROM users WHERE id = 1\")\n    assert.Equal(t, \"Bob\", result.Rows[0][0])\n}\n\nfunc TestEditRowNoPrimaryKey(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE data (value TEXT)\") // No PK\n    exec.Execute(\"INSERT INTO data VALUES ('test')\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/data/edit/1\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"no primary key\")\n}\n```\n\n## Definition of Done\n- [ ] GET /tables/{name}/edit/{pk} returns edit form partial\n- [ ] PUT /tables/{name}/{pk} executes UPDATE\n- [ ] Current values pre-populated in form\n- [ ] Primary key shown but not editable\n- [ ] SQL injection prevented\n- [ ] Success message on save\n- [ ] Error for tables without primary key\n- [ ] TestEditRowFormLoads passes\n- [ ] TestUpdateRowSuccess passes\n- [ ] TestEditRowNoPrimaryKey passes\n","status":"in_progress","priority":2,"issue_type":"task","assignee":"slit","created_at":"2026-01-07T16:55:40.796918-07:00","created_by":"mayor","updated_at":"2026-01-07T17:26:08.28654-07:00"}
{"id":"cdb-1rl","title":"Merge: nux-mk4f1dyr","description":"branch: polecat/nux-mk4f1dyr\ntarget: main\nsource_issue: nux-mk4f1dyr\nrig: claudedb\nagent_bead: claude-db-claudedb-polecat-nux\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T12:45:35.562316-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T16:09:17.946238-07:00","closed_at":"2026-01-07T16:09:17.946238-07:00","close_reason":"Already merged to main"}
{"id":"cdb-1tn","title":"Handle and display SQL errors","description":"## Problem\nSQL errors need to be displayed clearly to help users fix their queries.\n\n## Solution\nCreate partials/error.html template with error message and original query.\n\n## Implementation\n\n```html\n{{/* templates/partials/error.html */}}\n\u003cdiv class=\"query-error\" role=\"alert\"\u003e\n    \u003ch3\u003eError\u003c/h3\u003e\n    \u003cp class=\"error-message\"\u003e{{.Error}}\u003c/p\u003e\n    \n    {{if .Query}}\n    \u003cdetails\u003e\n        \u003csummary\u003eQuery\u003c/summary\u003e\n        \u003cpre class=\"error-query\"\u003e{{.Query}}\u003c/pre\u003e\n    \u003c/details\u003e\n    {{end}}\n    \n    {{if .Hint}}\n    \u003cp class=\"error-hint\"\u003eHint: {{.Hint}}\u003c/p\u003e\n    {{end}}\n\u003c/div\u003e\n```\n\n```go\n// Error hints for common issues\nfunc getErrorHint(err string) string {\n    switch {\n    case strings.Contains(err, \"no such table\"):\n        return \"Check table name spelling or run SHOW TABLES to see available tables.\"\n    case strings.Contains(err, \"no such column\"):\n        return \"Check column name or run DESCRIBE tablename to see columns.\"\n    case strings.Contains(err, \"syntax error\"):\n        return \"Check SQL syntax near the indicated position.\"\n    case strings.Contains(err, \"UNIQUE constraint\"):\n        return \"A row with this key already exists.\"\n    case strings.Contains(err, \"NOT NULL constraint\"):\n        return \"This column requires a value.\"\n    default:\n        return \"\"\n    }\n}\n```\n\n## Files to Create\n- internal/web/templates/partials/error.html\n- internal/web/errors.go (hint generation)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| SQL syntax error | Show error message with position if available |\n| Table not found | Show error + hint about SHOW TABLES |\n| Column not found | Show error + hint about DESCRIBE |\n| Constraint violation | Show which constraint failed |\n| Very long error message | Dont truncate, user needs full info |\n| Error with special chars | Properly escaped |\n| Empty error message | Show generic \"An error occurred\" |\n| Timeout error | Show \"Query timed out\" with duration |\n\n## Test Scenarios\n\n```go\nfunc TestErrorTemplateBasic(t *testing.T) {\n    data := map[string]string{\n        \"Error\": \"no such table: users\",\n        \"Query\": \"SELECT * FROM users\",\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/error.html\", data)\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"no such table\")\n    assert.Contains(t, html, \"SELECT * FROM users\")\n    assert.Contains(t, html, \"role=\\\"alert\\\"\")\n}\n\nfunc TestErrorTemplateWithHint(t *testing.T) {\n    data := map[string]string{\n        \"Error\": \"no such table: users\",\n        \"Query\": \"SELECT * FROM users\",\n        \"Hint\":  \"Check table name spelling\",\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/error.html\", data)\n    require.NoError(t, err)\n    \n    assert.Contains(t, buf.String(), \"Check table name\")\n}\n\nfunc TestErrorTemplateEscapesHTML(t *testing.T) {\n    data := map[string]string{\n        \"Error\": \"\u003cscript\u003ealert(1)\u003c/script\u003e\",\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/error.html\", data)\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.NotContains(t, html, \"\u003cscript\u003ealert\")\n    assert.Contains(t, html, \"\u0026lt;script\u0026gt;\")\n}\n\nfunc TestGetErrorHint(t *testing.T) {\n    tests := []struct {\n        err  string\n        want string\n    }{\n        {\"no such table: foo\", \"SHOW TABLES\"},\n        {\"no such column: bar\", \"DESCRIBE\"},\n        {\"syntax error\", \"syntax\"},\n        {\"random error\", \"\"},\n    }\n    \n    for _, tt := range tests {\n        hint := getErrorHint(tt.err)\n        if tt.want == \"\" {\n            assert.Empty(t, hint)\n        } else {\n            assert.Contains(t, hint, tt.want)\n        }\n    }\n}\n```\n\n## Definition of Done\n- [ ] partials/error.html template created\n- [ ] Error message prominently displayed\n- [ ] Original query shown in collapsible details\n- [ ] role=\"alert\" for accessibility\n- [ ] Helpful hints for common errors (table not found, etc)\n- [ ] HTML in error messages escaped\n- [ ] TestErrorTemplateBasic passes\n- [ ] TestErrorTemplateWithHint passes\n- [ ] TestErrorTemplateEscapesHTML passes\n- [ ] TestGetErrorHint passes\n","status":"closed","priority":1,"issue_type":"task","assignee":"dag","created_at":"2026-01-07T16:55:19.614103-07:00","created_by":"mayor","updated_at":"2026-01-07T17:33:19.729637-07:00","closed_at":"2026-01-07T17:33:19.729637-07:00","close_reason":"Closed","dependencies":[{"issue_id":"cdb-1tn","depends_on_id":"cdb-5us","type":"blocks","created_at":"2026-01-07T16:56:26.193126-07:00","created_by":"mayor"}]}
{"id":"cdb-21x","title":"Merge: dag-mk4iwbdo","description":"branch: polecat/dag-mk4iwbdo\ntarget: main\nsource_issue: dag-mk4iwbdo\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-dag\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:33:34.132625-07:00","created_by":"claudedb/polecats/dag","updated_at":"2026-01-07T17:33:34.132625-07:00"}
{"id":"cdb-25p","title":"dataPageIDs not persisted, Scan() returns empty after restart","description":"## Problem\n\nThe `dataPageIDs` field in `Table` is not persisted anywhere. After database restart, `Scan()` returns no rows even though data exists on disk.\n\n## Root Cause\n\n1. **TableInfo struct (catalog.go:40-46)** - Does not include `dataPageIDs`:\n   ```go\n   type TableInfo struct {\n       Name       string\n       RootPage   uint32\n       NextRowID  uint64\n       Columns    []ColumnInfo\n       PrimaryKey int\n       // dataPageIDs is MISSING!\n   }\n   ```\n\n2. **LoadTable (table.go)** - Creates empty slice:\n   ```go\n   func LoadTable(...) *Table {\n       return \u0026Table{\n           dataPageIDs: []uint32{},  // Always empty!\n       }\n   }\n   ```\n\n3. **Scan() (table.go:300-319)** - Iterates over `dataPageIDs`, which is empty after restart:\n   ```go\n   for _, pageID := range t.dataPageIDs {  // No iterations!\n       // ...\n   }\n   ```\n\n## Impact\n\nAfter database restart, SELECT queries return no rows. Data is still on disk but unreachable.\n\n## Suggested Fix\n\n**Option A: Persist dataPageIDs in catalog**\n- Add `DataPageIDs []uint32` to `TableInfo`\n- Serialize/deserialize in catalog read/write methods\n\n**Option B: Rebuild from B-tree on load**\n- Scan B-tree values (which contain pageID in upper 32 bits)\n- Collect unique page IDs to rebuild `dataPageIDs`\n```go\nfunc (t *Table) rebuildDataPageIDs() error {\n    _, values, _ := t.btree.Scan()\n    seen := make(map[uint32]bool)\n    for _, loc := range values {\n        pageID := uint32(loc \u003e\u003e 32)\n        if !seen[pageID] {\n            t.dataPageIDs = append(t.dataPageIDs, pageID)\n            seen[pageID] = true\n        }\n    }\n    return nil\n}\n```\n\n## Files Affected\n\n- internal/table/table.go\n- internal/catalog/catalog.go","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-04T06:10:50.588592-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:35:05.588179-07:00","closed_at":"2026-01-07T14:35:05.588179-07:00","close_reason":"Fixed: Added DataPageIDs to TableInfo, serialize/deserialize in catalog, table now restores dataPageIDs on load so Scan() works after restart"}
{"id":"cdb-28k","title":"HTTP Server Infrastructure","description":"Set up Go HTTP server with routing, templates, and static file serving. Foundation for all web UI features.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-07T16:52:47.986897-07:00","created_by":"mayor","updated_at":"2026-01-07T17:23:06.307804-07:00","closed_at":"2026-01-07T17:23:06.307804-07:00","close_reason":"All child tasks complete: HTTP server, base template, static files, middleware","dependencies":[{"issue_id":"cdb-28k","depends_on_id":"cdb-4i4","type":"blocks","created_at":"2026-01-07T16:56:17.050235-07:00","created_by":"mayor"},{"issue_id":"cdb-28k","depends_on_id":"cdb-anc","type":"blocks","created_at":"2026-01-07T16:56:17.091096-07:00","created_by":"mayor"},{"issue_id":"cdb-28k","depends_on_id":"cdb-3bt","type":"blocks","created_at":"2026-01-07T16:56:17.125542-07:00","created_by":"mayor"},{"issue_id":"cdb-28k","depends_on_id":"cdb-m45","type":"blocks","created_at":"2026-01-07T16:56:17.174889-07:00","created_by":"mayor"}]}
{"id":"cdb-2fy","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:09:57.902195-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T15:09:57.902195-07:00"}
{"id":"cdb-2tp","title":"Create query planner package","description":"Build a query planner that analyzes queries and chooses optimal execution strategy.\n\n## Current State\n- executor.go comment mentions planning but no planner exists\n- All queries go directly to execution with full scan\n\n## Implementation\n1. Create internal/sql/planner/ package\n2. Define QueryPlan interface with Execute() method\n3. Implement plan types:\n   - FullTableScan\n   - IndexScan (PK lookup)\n   - FilteredScan\n4. Planner analyzes WHERE clause + available indexes\n5. Executor calls planner.BuildPlan() then plan.Execute()\n\n## Example\n```go\ntype QueryPlan interface {\n    Execute(table *Table) ([]Row, error)\n}\n\ntype IndexScan struct {\n    index *BTree\n    key   []byte\n}\n\n// Usage in executor:\nplan := planner.BuildPlan(stmt, table)\nrows := plan.Execute(table)\n```\n\n## Files\n- NEW: internal/sql/planner/planner.go\n- NEW: internal/sql/planner/plans.go\n- MODIFY: internal/sql/executor/executor.go\n\n## Acceptance Criteria\n- Query planner package exists\n- Executor delegates access path choice to planner\n- Foundation for cost-based optimization","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T12:19:05.567201-07:00","created_by":"mayor","updated_at":"2026-01-07T14:05:19.910875-07:00","closed_at":"2026-01-07T12:21:32.770777-07:00","close_reason":"Superseded by existing claude-db-goh (Add query planner to analyze WHERE clauses) which has detailed design, edge cases, and test scenarios","dependencies":[{"issue_id":"cdb-2tp","depends_on_id":"cdb-epo","type":"blocks","created_at":"2026-01-07T12:19:19.419696-07:00","created_by":"mayor"},{"issue_id":"cdb-2tp","depends_on_id":"cdb-lyg","type":"blocks","created_at":"2026-01-07T12:19:19.454685-07:00","created_by":"mayor"}]}
{"id":"cdb-325","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:50:56.903941-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T15:50:56.903941-07:00"}
{"id":"cdb-32e","title":"Session ended: gt-claudedb-furiosa","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:31:53.692943-07:00","created_by":"claudedb/polecats/furiosa","updated_at":"2026-01-07T16:31:53.692943-07:00"}
{"id":"cdb-38k","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:07:57.74989-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T15:07:57.74989-07:00"}
{"id":"cdb-39m","title":"Merge: toast-mk4ivone","description":"branch: polecat/toast-mk4ivone\ntarget: main\nsource_issue: toast-mk4ivone\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-toast\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T14:27:18.485081-07:00","created_by":"claudedb/polecats/toast","updated_at":"2026-01-07T16:09:17.938304-07:00","closed_at":"2026-01-07T16:09:17.938304-07:00","close_reason":"Already merged to main"}
{"id":"cdb-3bt","title":"Add static file serving","description":"## Problem\nStatic assets (JS, CSS) need to be served by the web server.\n\n## Solution\nUse http.FileServer with embedded files or filesystem path.\n\n## Implementation\n\n```go\n// internal/web/static.go\npackage web\n\nimport (\n    \"embed\"\n    \"io/fs\"\n    \"net/http\"\n)\n\n//go:embed static/*\nvar staticFS embed.FS\n\nfunc (s *Server) staticRoutes() {\n    // Strip /static/ prefix and serve from embedded FS\n    staticContent, _ := fs.Sub(staticFS, \"static\")\n    fileServer := http.FileServer(http.FS(staticContent))\n    s.router.Handle(\"/static/*\", http.StripPrefix(\"/static/\", fileServer))\n}\n```\n\n## Files to Create\n- internal/web/static/htmx.min.js (download HTMX 1.9.x)\n- internal/web/static/style.css (minimal styles)\n- internal/web/static.go\n\n## HTMX Source\nDownload from: https://unpkg.com/htmx.org@1.9.10/dist/htmx.min.js\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| File not found | Return 404 |\n| Directory listing | Disabled (return 404 for dirs) |\n| Path traversal attempt | Blocked by http.FileServer |\n| Large file request | Stream without buffering |\n| Conditional GET (If-Modified-Since) | Return 304 if unchanged |\n\n## Test Scenarios\n\n```go\nfunc TestStaticFileServing(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/static/htmx.min.js\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    assert.Contains(t, resp.Header.Get(\"Content-Type\"), \"javascript\")\n}\n\nfunc TestStaticFileNotFound(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/static/nonexistent.js\")\n    require.NoError(t, err)\n    assert.Equal(t, 404, resp.StatusCode)\n}\n\nfunc TestPathTraversalBlocked(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/static/../../../etc/passwd\")\n    require.NoError(t, err)\n    assert.Equal(t, 404, resp.StatusCode)\n}\n```\n\n## Definition of Done\n- [ ] /static/* route configured\n- [ ] htmx.min.js downloadable at /static/htmx.min.js\n- [ ] style.css exists (can be minimal placeholder)\n- [ ] Files embedded with go:embed\n- [ ] 404 returned for missing files\n- [ ] Path traversal attempts blocked\n- [ ] TestStaticFileServing passes\n- [ ] TestStaticFileNotFound passes\n","status":"closed","priority":1,"issue_type":"task","assignee":"toast","created_at":"2026-01-07T16:53:05.798602-07:00","created_by":"mayor","updated_at":"2026-01-07T17:22:27.003302-07:00","closed_at":"2026-01-07T17:22:27.003302-07:00","close_reason":"Implemented static file serving with embedded FS. HTMX and CSS served at /static/*. All tests pass.","dependencies":[{"issue_id":"cdb-3bt","depends_on_id":"cdb-4i4","type":"blocks","created_at":"2026-01-07T16:56:17.245256-07:00","created_by":"mayor"}]}
{"id":"cdb-3f4","title":"Display query results as HTML table","description":"## Problem\nQuery results need to be displayed as an HTML table.\n\n## Solution\nCreate partials/results.html template that renders column headers and row data.\n\n## Implementation\n\n```html\n{{/* templates/partials/results.html */}}\n\u003cdiv class=\"query-results\"\u003e\n    \u003cdiv class=\"results-meta\"\u003e\n        \u003cspan class=\"row-count\"\u003e{{.RowCount}} row(s) returned\u003c/span\u003e\n        {{if .Duration}}\n        \u003cspan class=\"duration\"\u003ein {{.Duration}}\u003c/span\u003e\n        {{end}}\n    \u003c/div\u003e\n    \n    {{if gt .RowCount 0}}\n    \u003cdiv class=\"table-wrapper\"\u003e\n        \u003ctable class=\"results-table\"\u003e\n            \u003cthead\u003e\n                \u003ctr\u003e\n                    {{range .Columns}}\n                    \u003cth\u003e{{.Name}}\u003c/th\u003e\n                    {{end}}\n                \u003c/tr\u003e\n            \u003c/thead\u003e\n            \u003ctbody\u003e\n                {{range .Rows}}\n                \u003ctr\u003e\n                    {{range .}}\n                    \u003ctd\u003e{{renderValue .}}\u003c/td\u003e\n                    {{end}}\n                \u003c/tr\u003e\n                {{end}}\n            \u003c/tbody\u003e\n        \u003c/table\u003e\n    \u003c/div\u003e\n    {{else}}\n    \u003cp class=\"no-results\"\u003eQuery returned no rows.\u003c/p\u003e\n    {{end}}\n\u003c/div\u003e\n```\n\n```go\n// Template function for rendering values\nfunc renderValue(v interface{}) template.HTML {\n    if v == nil {\n        return template.HTML(\"\u003cspan class=\\\"null\\\"\u003eNULL\u003c/span\u003e\")\n    }\n    \n    str := fmt.Sprintf(\"%v\", v)\n    \n    // Truncate very long values\n    const maxLen = 100\n    if len(str) \u003e maxLen {\n        str = str[:maxLen] + \"...\"\n    }\n    \n    // Escape HTML\n    return template.HTML(template.HTMLEscapeString(str))\n}\n```\n\n## Files to Create\n- internal/web/templates/partials/results.html\n- internal/web/template_funcs.go (renderValue function)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| 0 rows | Show \"Query returned no rows\" message |\n| 0 columns | Show empty table (edge case from db) |\n| NULL value | Show styled \"NULL\" span |\n| Empty string | Show empty cell (not NULL) |\n| Very long text (\u003e100 chars) | Truncate with \"...\" |\n| HTML in data | Escaped, not rendered |\n| Unicode characters | Display correctly |\n| BLOB/binary data | Show \"[BLOB]\" or hex preview |\n| Integer 0 | Show \"0\", not empty |\n| Boolean false | Show \"false\", not empty |\n| 1000+ rows | Render all (pagination separate task) |\n\n## Test Scenarios\n\n```go\nfunc TestResultsTemplateBasic(t *testing.T) {\n    data := map[string]interface{}{\n        \"Columns\":  []Column{{Name: \"id\"}, {Name: \"name\"}},\n        \"Rows\":     [][]interface{}{{1, \"Alice\"}, {2, \"Bob\"}},\n        \"RowCount\": 2,\n        \"Duration\": \"5ms\",\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/results.html\", data)\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"2 row(s)\")\n    assert.Contains(t, html, \"\u003cth\u003eid\u003c/th\u003e\")\n    assert.Contains(t, html, \"\u003cth\u003ename\u003c/th\u003e\")\n    assert.Contains(t, html, \"Alice\")\n    assert.Contains(t, html, \"Bob\")\n}\n\nfunc TestResultsTemplateEmpty(t *testing.T) {\n    data := map[string]interface{}{\n        \"Columns\":  []Column{{Name: \"id\"}},\n        \"Rows\":     [][]interface{}{},\n        \"RowCount\": 0,\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/results.html\", data)\n    require.NoError(t, err)\n    \n    assert.Contains(t, buf.String(), \"no rows\")\n}\n\nfunc TestResultsTemplateNull(t *testing.T) {\n    data := map[string]interface{}{\n        \"Columns\":  []Column{{Name: \"value\"}},\n        \"Rows\":     [][]interface{}{{nil}},\n        \"RowCount\": 1,\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/results.html\", data)\n    require.NoError(t, err)\n    \n    assert.Contains(t, buf.String(), \"class=\\\"null\\\"\")\n    assert.Contains(t, buf.String(), \"NULL\")\n}\n\nfunc TestResultsTemplateEscapesHTML(t *testing.T) {\n    data := map[string]interface{}{\n        \"Columns\":  []Column{{Name: \"data\"}},\n        \"Rows\":     [][]interface{}{{\"\u003cscript\u003ealert(1)\u003c/script\u003e\"}},\n        \"RowCount\": 1,\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/results.html\", data)\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.NotContains(t, html, \"\u003cscript\u003ealert\")\n    assert.Contains(t, html, \"\u0026lt;script\u0026gt;\")\n}\n\nfunc TestResultsTemplateTruncatesLong(t *testing.T) {\n    longValue := strings.Repeat(\"x\", 200)\n    data := map[string]interface{}{\n        \"Columns\":  []Column{{Name: \"data\"}},\n        \"Rows\":     [][]interface{}{{longValue}},\n        \"RowCount\": 1,\n    }\n    \n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"partials/results.html\", data)\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"...\")\n    assert.Less(t, len(html), len(longValue)+500) // Much smaller than input\n}\n```\n\n## Definition of Done\n- [ ] partials/results.html template created\n- [ ] Shows row count and query duration\n- [ ] Table with column headers from result schema\n- [ ] Rows rendered with proper escaping\n- [ ] NULL values show styled indicator\n- [ ] Long values truncated with ellipsis\n- [ ] Empty results show friendly message\n- [ ] HTML in data is escaped\n- [ ] TestResultsTemplateBasic passes\n- [ ] TestResultsTemplateEmpty passes\n- [ ] TestResultsTemplateNull passes\n- [ ] TestResultsTemplateEscapesHTML passes\n- [ ] TestResultsTemplateTruncatesLong passes\n","status":"closed","priority":1,"issue_type":"task","assignee":"nux","created_at":"2026-01-07T16:55:19.380497-07:00","created_by":"mayor","updated_at":"2026-01-07T17:31:45.15924-07:00","closed_at":"2026-01-07T17:31:45.15924-07:00","close_reason":"Implemented HTML templates for query results with renderValue function, NULL handling, truncation, and HTML escaping","dependencies":[{"issue_id":"cdb-3f4","depends_on_id":"cdb-5us","type":"blocks","created_at":"2026-01-07T16:56:26.153453-07:00","created_by":"mayor"}]}
{"id":"cdb-3gh","title":"Merge: dag-mk4iwbdo","description":"branch: polecat/dag-mk4iwbdo\ntarget: main\nsource_issue: dag-mk4iwbdo\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-dag\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:30:55.36264-07:00","created_by":"claudedb/polecats/dag","updated_at":"2026-01-07T17:30:55.36264-07:00"}
{"id":"cdb-3ik","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:09:09.72661-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T16:09:09.72661-07:00"}
{"id":"cdb-3xr","title":"test-agent-actual","status":"closed","priority":2,"issue_type":"agent","created_at":"2026-01-07T15:56:19.571325-07:00","created_by":"mayor","updated_at":"2026-01-07T15:56:24.623171-07:00","closed_at":"2026-01-07T15:56:24.623171-07:00","close_reason":"test cleanup"}
{"id":"cdb-3yt","title":"Merge: furiosa-mk4ewicq","description":"branch: polecat/furiosa-mk4ewicq\ntarget: main\nsource_issue: furiosa-mk4ewicq\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-furiosa\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T16:31:35.24135-07:00","created_by":"claudedb/polecats/furiosa","updated_at":"2026-01-07T16:43:44.231803-07:00","closed_at":"2026-01-07T16:43:44.231803-07:00","close_reason":"Merged to main"}
{"id":"cdb-407","title":"bd --no-daemon write operations don't follow routing","description":"## Bug\n\nWrite operations like `bd update` in `--no-daemon` (direct) mode do not follow prefix routing from routes.jsonl.\n\n## Reproduction\n\nFrom town root (/Users/cabewaldrop/gt):\n\n```bash\n# Works - read operation follows routing\nbd --no-daemon show cdb-lyg\n\n# Fails - write operation doesn't follow routing  \nbd --no-daemon update cdb-lyg --status=hooked\n# Error: no issue found matching 'cdb-lyg'\n```\n\n## Expected\n\nBoth read and write operations should follow routing in direct mode.\n\n## Impact\n\n`gt sling` uses `--no-daemon` mode for hook operations, causing sling to fail for cross-rig work.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-07T14:32:17.957475-07:00","created_by":"mayor","updated_at":"2026-01-07T14:59:46.921737-07:00","closed_at":"2026-01-07T14:59:46.921737-07:00","close_reason":"Fixed by upgrading bd from 0.43.0 to 0.46.0. The routing bug was already fixed in the upstream beads repo."}
{"id":"cdb-427","title":"nextRowID not properly persisted and restored on table load","description":"## Problem\n\nWhen a table is loaded from disk after restart, `nextRowID` is always reset to 1, causing duplicate row IDs.\n\n## Root Cause\n\nTwo issues:\n\n1. **catalog.go:300** - When saving table metadata, `NextRowID` is hardcoded to 1 instead of reading from the table:\n   ```go\n   info := \u0026TableInfo{\n       NextRowID:  1,  // BUG: should be tbl.nextRowID\n   }\n   ```\n\n2. **table.go LoadTable()** - The function doesn't accept `nextRowID` as a parameter and hardcodes it to 1:\n   ```go\n   func LoadTable(..., rootPage uint32) *Table {\n       return \u0026Table{\n           nextRowID: 1,  // BUG: ignores persisted value\n       }\n   }\n   ```\n\n3. **catalog.go:358** - `LoadTable` call doesn't pass `info.NextRowID`.\n\n## Impact\n\nAfter database restart, inserting new rows will reuse IDs 1, 2, 3... causing primary key conflicts or data corruption.\n\n## Suggested Fix\n\n1. Add a getter `Table.GetNextRowID()` or make field accessible\n2. Update `AddTable()` to read actual nextRowID from table\n3. Add `nextRowID` parameter to `LoadTable()`\n4. Pass `info.NextRowID` when loading tables\n\n## Files Affected\n\n- internal/table/table.go\n- internal/catalog/catalog.go","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-04T06:10:22.108089-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:32:16.412611-07:00","closed_at":"2026-01-07T14:32:16.412611-07:00","close_reason":"Fixed: Added GetNextRowID() getter, updated LoadTable to accept nextRowID parameter, catalog now saves and restores actual nextRowID value"}
{"id":"cdb-4i4","title":"Set up HTTP server with chi router","description":"## Problem\nThe web UI needs an HTTP server foundation to handle requests.\n\n## Solution\nCreate internal/web/server.go with chi router, middleware stack, and graceful shutdown.\n\n## Implementation\n\n```go\npackage web\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/go-chi/chi/v5\"\n    \"github.com/go-chi/chi/v5/middleware\"\n)\n\ntype Server struct {\n    router *chi.Mux\n    port   int\n    db     *sql.Executor  // injected\n}\n\nfunc NewServer(port int, executor *sql.Executor) *Server {\n    r := chi.NewRouter()\n    \n    // Middleware stack\n    r.Use(middleware.RequestID)\n    r.Use(middleware.RealIP)\n    r.Use(middleware.Logger)\n    r.Use(middleware.Recoverer)\n    r.Use(middleware.Timeout(30 * time.Second))\n    \n    s := \u0026Server{router: r, port: port, db: executor}\n    s.routes()\n    return s\n}\n\nfunc (s *Server) routes() {\n    s.router.Get(\"/\", s.handleIndex)\n    s.router.Get(\"/health\", s.handleHealth)\n    // Static files, query endpoints added by other tasks\n}\n\nfunc (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"ok\"))\n}\n\nfunc (s *Server) Run() error {\n    srv := \u0026http.Server{\n        Addr:    fmt.Sprintf(\":%d\", s.port),\n        Handler: s.router,\n    }\n    \n    // Graceful shutdown\n    done := make(chan os.Signal, 1)\n    signal.Notify(done, os.Interrupt, syscall.SIGTERM)\n    \n    go func() {\n        \u003c-done\n        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n        defer cancel()\n        srv.Shutdown(ctx)\n    }()\n    \n    return srv.ListenAndServe()\n}\n```\n\n## Files to Create\n- internal/web/server.go\n- internal/web/handlers.go (stub for route handlers)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Port already in use | Clear error message, exit gracefully |\n| Invalid port number | Validation error at startup |\n| SIGTERM received | Graceful shutdown, finish in-flight requests |\n| SIGINT (Ctrl+C) | Same as SIGTERM |\n| Request timeout | Return 503 after 30s |\n| Panic in handler | Recover, log stack trace, return 500 |\n\n## Test Scenarios\n\n```go\nfunc TestServerStartup(t *testing.T) {\n    exec := setupTestExecutor(t)\n    srv := NewServer(0, exec) // port 0 = random available port\n    \n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/health\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n}\n\nfunc TestServerRecovery(t *testing.T) {\n    srv := NewServer(0, nil)\n    srv.router.Get(\"/panic\", func(w http.ResponseWriter, r *http.Request) {\n        panic(\"test panic\")\n    })\n    \n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/panic\")\n    require.NoError(t, err)\n    assert.Equal(t, 500, resp.StatusCode) // Recovered, not crashed\n}\n```\n\n## Definition of Done\n- [ ] internal/web/server.go exists with Server struct\n- [ ] chi router configured with middleware stack\n- [ ] /health endpoint returns 200 OK\n- [ ] Graceful shutdown on SIGTERM/SIGINT\n- [ ] Panic recovery returns 500 without crashing\n- [ ] Request timeout after 30 seconds\n- [ ] TestServerStartup passes\n- [ ] TestServerRecovery passes\n- [ ] Server can be started with: go run ./cmd/claude-db web --port 8080\n","status":"closed","priority":1,"issue_type":"task","assignee":"claudedb/polecats/capable","created_at":"2026-01-07T16:53:05.692522-07:00","created_by":"mayor","updated_at":"2026-01-07T17:11:33.258664-07:00","closed_at":"2026-01-07T17:11:33.258664-07:00","close_reason":"HTTP server with chi router implemented. Middleware stack, graceful shutdown, /health endpoint, panic recovery. All tests pass."}
{"id":"cdb-4js","title":"Insert row form and handler","description":"## Problem\nUsers need to insert data without writing INSERT statements.\n\n## Solution\nDynamic form at /tables/{name}/insert based on table schema.\n\n## Implementation\n\n```html\n{{/* templates/table_insert.html */}}\n{{define \"title\"}}Insert into {{.Table}} - claudedb{{end}}\n\n{{define \"content\"}}\n\u003cdiv class=\"insert-page\"\u003e\n    \u003cnav class=\"breadcrumb\"\u003e\n        \u003ca href=\"/tables\"\u003eTables\u003c/a\u003e / \n        \u003ca href=\"/tables/{{.Table}}\"\u003e{{.Table}}\u003c/a\u003e / \n        \u003cspan\u003eInsert\u003c/span\u003e\n    \u003c/nav\u003e\n    \n    \u003ch1\u003eInsert Row\u003c/h1\u003e\n    \n    \u003cform hx-post=\"/tables/{{.Table}}/insert\" hx-target=\"#result\"\u003e\n        {{range .Columns}}\n        \u003cdiv class=\"form-group\"\u003e\n            \u003clabel for=\"col-{{.Name}}\"\u003e\n                {{.Name}} \n                \u003cspan class=\"type-hint\"\u003e({{.Type}})\u003c/span\u003e\n                {{if .IsPrimaryKey}}\u003cspan class=\"badge pk\"\u003ePK\u003c/span\u003e{{end}}\n                {{if .NotNull}}\u003cspan class=\"badge required\"\u003eRequired\u003c/span\u003e{{end}}\n            \u003c/label\u003e\n            \n            {{if eq .Type \"TEXT\"}}\n            \u003ctextarea id=\"col-{{.Name}}\" name=\"{{.Name}}\" \n                      {{if .NotNull}}required{{end}}\u003e\u003c/textarea\u003e\n            {{else if eq .Type \"INTEGER\"}}\n            \u003cinput type=\"number\" id=\"col-{{.Name}}\" name=\"{{.Name}}\"\n                   {{if .NotNull}}required{{end}}\u003e\n            {{else if eq .Type \"REAL\"}}\n            \u003cinput type=\"number\" step=\"any\" id=\"col-{{.Name}}\" name=\"{{.Name}}\"\n                   {{if .NotNull}}required{{end}}\u003e\n            {{else}}\n            \u003cinput type=\"text\" id=\"col-{{.Name}}\" name=\"{{.Name}}\"\n                   {{if .NotNull}}required{{end}}\u003e\n            {{end}}\n            \n            {{if .Default}}\n            \u003csmall\u003eDefault: {{.Default}}\u003c/small\u003e\n            {{end}}\n        \u003c/div\u003e\n        {{end}}\n        \n        \u003cdiv class=\"form-actions\"\u003e\n            \u003cbutton type=\"submit\" class=\"btn-primary\"\u003eInsert\u003c/button\u003e\n            \u003cbutton type=\"submit\" name=\"insert_another\" value=\"1\" class=\"btn-secondary\"\u003e\n                Insert \u0026 Add Another\n            \u003c/button\u003e\n            \u003ca href=\"/tables/{{.Table}}/data\" class=\"btn\"\u003eCancel\u003c/a\u003e\n        \u003c/div\u003e\n    \u003c/form\u003e\n    \n    \u003cdiv id=\"result\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n{{end}}\n```\n\n```go\nfunc (s *Server) handleInsertRow(w http.ResponseWriter, r *http.Request) {\n    tableName := chi.URLParam(r, \"name\")\n    exec := GetExecutor(r)\n    \n    if r.Method == http.MethodGet {\n        schema, err := exec.GetTableSchema(tableName)\n        if err != nil {\n            http.Error(w, \"Table not found\", 404)\n            return\n        }\n        renderTemplate(w, \"table_insert.html\", map[string]interface{}{\n            \"Table\":   tableName,\n            \"Columns\": schemaToColumnInfo(schema),\n        })\n        return\n    }\n    \n    // POST: Insert the row\n    schema, _ := exec.GetTableSchema(tableName)\n    \n    var columns []string\n    var values []string\n    \n    for _, col := range schema.Columns {\n        value := r.FormValue(col.Name)\n        \n        // Skip empty non-required fields\n        if value == \"\" \u0026\u0026 !col.NotNull {\n            continue\n        }\n        \n        columns = append(columns, col.Name)\n        \n        // Quote strings, leave numbers unquoted\n        if col.Type == \"TEXT\" || col.Type == \"BLOB\" {\n            values = append(values, fmt.Sprintf(\"'%s'\", escapeSQL(value)))\n        } else if value == \"\" {\n            values = append(values, \"NULL\")\n        } else {\n            values = append(values, value)\n        }\n    }\n    \n    sql := fmt.Sprintf(\"INSERT INTO %s (%s) VALUES (%s)\",\n        tableName,\n        strings.Join(columns, \", \"),\n        strings.Join(values, \", \"))\n    \n    _, err := exec.Execute(sql)\n    if err != nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": err.Error(),\n            \"Query\": sql,\n        })\n        return\n    }\n    \n    if r.FormValue(\"insert_another\") == \"1\" {\n        renderTemplate(w, \"partials/success.html\", map[string]string{\n            \"Message\": \"Row inserted. Add another?\",\n        })\n        return\n    }\n    \n    w.Header().Set(\"HX-Redirect\", \"/tables/\"+tableName+\"/data\")\n    w.WriteHeader(200)\n}\n\nfunc escapeSQL(s string) string {\n    return strings.ReplaceAll(s, \"'\", \"''\")\n}\n```\n\n## Files to Create\n- internal/web/templates/table_insert.html\n- internal/web/handlers.go (handleInsertRow)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Missing required field | HTML5 validation prevents submit |\n| Empty optional field | Use NULL or omit from INSERT |\n| Invalid integer | Validation error |\n| SQL injection attempt | Escaped via escapeSQL |\n| Very long text | Accept, database handles limits |\n| Primary key conflict | SQL error \"UNIQUE constraint\" |\n| Insert into view | SQL error |\n| BLOB data | Accept as text (base64?) |\n\n## Test Scenarios\n\n```go\nfunc TestInsertFormRenders(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/users/insert\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"Insert Row\")\n    assert.Contains(t, html, \"name=\\\"id\\\"\")\n    assert.Contains(t, html, \"name=\\\"name\\\"\")\n    assert.Contains(t, html, \"required\")\n}\n\nfunc TestInsertRowSuccess(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/tables/users/insert\", url.Values{\n        \"id\":   {\"1\"},\n        \"name\": {\"Alice\"},\n    })\n    require.NoError(t, err)\n    \n    // Verify row inserted\n    result, _ := exec.Execute(\"SELECT * FROM users WHERE id = 1\")\n    assert.Equal(t, 1, len(result.Rows))\n    assert.Equal(t, \"Alice\", result.Rows[0][1])\n}\n\nfunc TestInsertRowSQLInjection(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/tables/users/insert\", url.Values{\n        \"id\":   {\"1\"},\n        \"name\": {\"Robert'); DROP TABLE users;--\"},\n    })\n    require.NoError(t, err)\n    \n    // Table should still exist\n    tables := exec.ListTables()\n    assert.Contains(t, tables, \"users\")\n    \n    // Name should be stored literally\n    result, _ := exec.Execute(\"SELECT name FROM users WHERE id = 1\")\n    assert.Contains(t, result.Rows[0][0].(string), \"DROP TABLE\")\n}\n```\n\n## Definition of Done\n- [ ] GET /tables/{name}/insert shows form\n- [ ] Form fields generated from table schema\n- [ ] Appropriate input types (number, textarea, etc)\n- [ ] Required fields marked and validated\n- [ ] POST /tables/{name}/insert executes INSERT\n- [ ] SQL injection prevented via escaping\n- [ ] Success shows message or redirects\n- [ ] \"Insert Another\" stays on form\n- [ ] TestInsertFormRenders passes\n- [ ] TestInsertRowSuccess passes\n- [ ] TestInsertRowSQLInjection passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"valkyrie","created_at":"2026-01-07T16:55:40.584709-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:10.647451-07:00","closed_at":"2026-01-07T17:32:10.647451-07:00","close_reason":"Implemented insert row form with template rendering, handleInsertRow handler, and SQL injection prevention. All tests pass."}
{"id":"cdb-4kh","title":"Merge: capable-mk4ito0g","description":"branch: polecat/capable-mk4ito0g\ntarget: main\nsource_issue: capable-mk4ito0g\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-capable\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:32:27.971918-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T17:32:27.971918-07:00"}
{"id":"cdb-562","title":"Session ended: gt-claudedb-valkyrie","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:05:25.393465-07:00","created_by":"claudedb/polecats/valkyrie","updated_at":"2026-01-07T16:05:25.393465-07:00"}
{"id":"cdb-583","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:25:49.02563-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T15:25:49.02563-07:00"}
{"id":"cdb-5as","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:19:52.413423-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T16:19:52.413423-07:00"}
{"id":"cdb-5j0","title":"List all tables endpoint","description":"## Problem\nUsers need to see what tables exist in the database.\n\n## Solution\nGET /tables endpoint that lists all tables with links to details.\n\n## Implementation\n\n```html\n{{/* templates/tables.html */}}\n{{define \"title\"}}Tables - claudedb{{end}}\n\n{{define \"content\"}}\n\u003cdiv class=\"tables-page\"\u003e\n    \u003ch1\u003eTables\u003c/h1\u003e\n    \n    \u003cdiv class=\"actions\"\u003e\n        \u003ca href=\"/tables/new\" class=\"btn-primary\"\u003eCreate Table\u003c/a\u003e\n    \u003c/div\u003e\n    \n    {{if .Tables}}\n    \u003cul class=\"table-list\"\u003e\n        {{range .Tables}}\n        \u003cli\u003e\n            \u003ca href=\"/tables/{{.Name}}\" class=\"table-link\"\u003e\n                \u003cspan class=\"table-name\"\u003e{{.Name}}\u003c/span\u003e\n                \u003cspan class=\"table-meta\"\u003e{{.RowCount}} rows\u003c/span\u003e\n            \u003c/a\u003e\n        \u003c/li\u003e\n        {{end}}\n    \u003c/ul\u003e\n    {{else}}\n    \u003cp class=\"no-tables\"\u003eNo tables found. \u003ca href=\"/tables/new\"\u003eCreate one?\u003c/a\u003e\u003c/p\u003e\n    {{end}}\n\u003c/div\u003e\n{{end}}\n```\n\n```go\n// internal/web/handlers.go\ntype TableInfo struct {\n    Name     string\n    RowCount int\n}\n\nfunc (s *Server) handleTableList(w http.ResponseWriter, r *http.Request) {\n    exec := GetExecutor(r)\n    if exec == nil {\n        http.Error(w, \"Database not available\", 500)\n        return\n    }\n    \n    // Get table names from catalog\n    tables := exec.ListTables()\n    \n    var tableInfos []TableInfo\n    for _, name := range tables {\n        // Get row count for each table\n        result, err := exec.Execute(fmt.Sprintf(\"SELECT COUNT(*) FROM %s\", name))\n        count := 0\n        if err == nil \u0026\u0026 len(result.Rows) \u003e 0 {\n            count, _ = result.Rows[0][0].(int)\n        }\n        tableInfos = append(tableInfos, TableInfo{Name: name, RowCount: count})\n    }\n    \n    renderTemplate(w, \"tables.html\", map[string]interface{}{\n        \"Tables\": tableInfos,\n    })\n}\n```\n\n## Files to Create/Modify\n- internal/web/templates/tables.html\n- internal/web/handlers.go (handleTableList)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| No tables | Show friendly \"no tables\" message with create link |\n| Many tables (100+) | Consider pagination or alphabetical grouping |\n| Table with special chars in name | Properly URL-encoded in link |\n| COUNT(*) fails | Show \"?\" for row count, dont fail page |\n| System/internal tables | Filter out or mark as system |\n\n## Test Scenarios\n\n```go\nfunc TestTableListEmpty(t *testing.T) {\n    exec := setupTestExecutor(t)\n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"No tables\")\n    assert.Contains(t, string(body), \"Create one\")\n}\n\nfunc TestTableListWithTables(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY)\")\n    exec.Execute(\"CREATE TABLE posts (id INTEGER PRIMARY KEY)\")\n    exec.Execute(\"INSERT INTO users VALUES (1)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"users\")\n    assert.Contains(t, html, \"posts\")\n    assert.Contains(t, html, \"1 rows\") // users has 1 row\n    assert.Contains(t, html, \"0 rows\") // posts has 0 rows\n}\n\nfunc TestTableListLinks(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE my_table (id INTEGER PRIMARY KEY)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"href=\\\"/tables/my_table\\\"\")\n}\n```\n\n## Definition of Done\n- [ ] GET /tables route registered\n- [ ] Lists all tables with names and row counts\n- [ ] Each table links to /tables/{name}\n- [ ] Create Table button links to /tables/new\n- [ ] Empty state shows helpful message\n- [ ] TestTableListEmpty passes\n- [ ] TestTableListWithTables passes\n- [ ] TestTableListLinks passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"toast","created_at":"2026-01-07T16:55:27.307073-07:00","created_by":"mayor","updated_at":"2026-01-07T17:29:53.830012-07:00","closed_at":"2026-01-07T17:29:53.830012-07:00","close_reason":"Implemented GET /tables endpoint with template rendering. Lists all tables with row counts. All tests pass."}
{"id":"cdb-5jc","title":"Add Table.GetRowByLocation() for index lookups","description":"## Problem\nThe B-tree `Search()` returns a row location as `(pageID \u003c\u003c 32 | offset)`, but Table has no method to retrieve a row by this location. This is a fundamental building block needed before any index-based query optimization can work.\n\n## Solution\nAdd a method to retrieve a single row by its physical location:\n\n```go\n// GetRowByLocation retrieves a row using the location from B-tree lookup.\n// Location format: (pageID \u003c\u003c 32) | offset\nfunc (t *Table) GetRowByLocation(location uint64) (Row, error) {\n    pageID := uint32(location \u003e\u003e 32)\n    offset := uint16(location \u0026 0xFFFF)\n    \n    page, err := t.pager.GetPage(pageID)\n    if err != nil {\n        return Row{}, fmt.Errorf(\"page %d not found: %w\", pageID, err)\n    }\n    \n    data := page.GetData()\n    if int(offset) \u003e= len(data)-1 {\n        return Row{}, fmt.Errorf(\"offset %d out of bounds for page %d\", offset, pageID)\n    }\n    \n    length := binary.LittleEndian.Uint16(data[offset:])\n    if length == 0 {\n        return Row{}, fmt.Errorf(\"invalid row at offset %d: zero length\", offset)\n    }\n    \n    endOffset := int(offset) + 2 + int(length)\n    if endOffset \u003e len(data) {\n        return Row{}, fmt.Errorf(\"row data exceeds page boundary\")\n    }\n    \n    rowData := data[offset+2 : endOffset]\n    return t.deserializeRow(rowData)\n}\n```\n\n## Files to Modify\n- internal/table/table.go\n\n## Edge Cases\n\n| Case | Input | Expected Behavior |\n|------|-------|-------------------|\n| Zero location | `location = 0` | Error: \"page 0 not found\" or valid if page 0 exists |\n| Invalid page ID | `pageID = 999999` | Error: \"page 999999 not found: ...\" |\n| Offset past data | `offset \u003e len(page.data)` | Error: \"offset N out of bounds for page M\" |\n| Zero-length row | `length = 0` at offset | Error: \"invalid row at offset N: zero length\" |\n| Row exceeds page | `offset + length \u003e pageSize` | Error: \"row data exceeds page boundary\" |\n| Valid location | Normal B-tree lookup result | Returns correct Row with matching ID |\n\n## Test Scenarios\n\n```go\nfunc TestGetRowByLocation(t *testing.T) {\n    // Setup: Create table, insert row, get location from B-tree\n    tbl := createTestTable(t)\n    rowID, _ := tbl.Insert([]Value{{Type: TypeInteger, Integer: 42}, {Type: TypeText, Text: \"hello\"}})\n    \n    // Get location via B-tree (this is how it will be used)\n    keyBytes := intToBytes(42)\n    location, found, _ := tbl.btree.Search(keyBytes)\n    require.True(t, found)\n    \n    // Test 1: Valid location returns correct row\n    row, err := tbl.GetRowByLocation(location)\n    require.NoError(t, err)\n    assert.Equal(t, rowID, row.ID)\n    assert.Equal(t, int64(42), row.Values[0].Integer)\n    assert.Equal(t, \"hello\", row.Values[1].Text)\n    \n    // Test 2: Invalid page ID\n    badLocation := uint64(999999) \u003c\u003c 32\n    _, err = tbl.GetRowByLocation(badLocation)\n    assert.ErrorContains(t, err, \"page 999999 not found\")\n    \n    // Test 3: Offset past page boundary\n    badOffset := uint64(pageID) \u003c\u003c 32 | uint64(5000)\n    _, err = tbl.GetRowByLocation(badOffset)\n    assert.ErrorContains(t, err, \"out of bounds\")\n}\n```\n\n## Agent Verification Checklist\n\nRun these commands and verify the expected outcomes:\n\n```bash\n# 1. Code compiles\ngo build ./...\n# Expected: exit code 0, no errors\n\n# 2. Unit tests pass\ngo test ./internal/table/... -v -run TestGetRowByLocation\n# Expected: PASS\n\n# 3. Method signature exists\ngrep -n \"func (t \\*Table) GetRowByLocation\" internal/table/table.go\n# Expected: Returns line number with correct signature\n\n# 4. Error handling exists (check for wrapped errors)\ngrep -c \"fmt.Errorf\" internal/table/table.go\n# Expected: At least 3 new error cases added\n```\n\n## Definition of Done\n- [ ] `GetRowByLocation(location uint64) (Row, error)` method exists on Table\n- [ ] All 5 edge cases from table above are handled with specific error messages\n- [ ] `TestGetRowByLocation` test file exists and passes\n- [ ] Integration test: Insert row  B-tree Search  GetRowByLocation  verify row matches\n- [ ] `go test ./internal/table/... -v` shows all tests passing","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-05T05:48:49.071027-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:05:19.907075-07:00","closed_at":"2026-01-07T13:17:11.510595-07:00","close_reason":"Implemented by furiosa in commit f6183b8: feat(table): add GetRowByLocation() for index lookups"}
{"id":"cdb-5me","title":"Session ended: gt-claudedb-capable","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:17:09.246804-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T16:17:09.246804-07:00"}
{"id":"cdb-5us","title":"Implement query execution handler","description":"## Problem\nNeed to execute SQL queries from web form and return results.\n\n## Solution\nPOST /query handler that executes SQL via executor and returns HTML partial.\n\n## Implementation\n\n```go\n// internal/web/handlers.go\nfunc (s *Server) handleQueryExecute(w http.ResponseWriter, r *http.Request) {\n    if r.Method \\!= http.MethodPost {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n    \n    sql := strings.TrimSpace(r.FormValue(\"sql\"))\n    if sql == \"\" {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Query cannot be empty\",\n        })\n        return\n    }\n    \n    // Limit query length to prevent abuse\n    const maxQueryLen = 10000\n    if len(sql) \u003e maxQueryLen {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": fmt.Sprintf(\"Query too long (max %d characters)\", maxQueryLen),\n        })\n        return\n    }\n    \n    exec := GetExecutor(r)\n    if exec == nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Database not available\",\n        })\n        return\n    }\n    \n    // Execute with timeout from request context\n    ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)\n    defer cancel()\n    \n    // Check if EXPLAIN requested\n    if r.FormValue(\"explain\") == \"1\" {\n        sql = \"EXPLAIN \" + sql\n    }\n    \n    result, err := exec.ExecuteWithContext(ctx, sql)\n    if err \\!= nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": err.Error(),\n            \"Query\": sql,\n        })\n        return\n    }\n    \n    renderTemplate(w, \"partials/results.html\", map[string]interface{}{\n        \"Columns\":  result.Columns,\n        \"Rows\":     result.Rows,\n        \"RowCount\": len(result.Rows),\n        \"Query\":    sql,\n        \"Duration\": result.Duration,\n    })\n}\n```\n\n## Files to Modify\n- internal/web/handlers.go\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Empty query | Return error partial with message |\n| Query \u003e 10KB | Return error \"Query too long\" |\n| SQL syntax error | Return error partial with SQL error message |\n| Query timeout (\u003e30s) | Return error \"Query timed out\" |\n| Multi-statement (;) | Execute all, return last result (or error) |\n| DROP/DELETE | Execute normally (no confirmation in API) |\n| SELECT returns 0 rows | Show empty table, not error |\n| SELECT returns 10000 rows | Render all (pagination in separate task) |\n| Non-SELECT (INSERT) | Show affected rows message |\n| Context cancelled | Clean abort, partial error |\n\n## Test Scenarios\n\n```go\nfunc TestQueryExecuteSuccess(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)\")\n    exec.Execute(\"INSERT INTO test VALUES (1, 'Alice')\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/query\", url.Values{\n        \"sql\": {\"SELECT * FROM test\"},\n    })\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"Alice\")\n    assert.Contains(t, string(body), \"\u003ctable\")\n}\n\nfunc TestQueryExecuteError(t *testing.T) {\n    exec := setupTestExecutor(t)\n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/query\", url.Values{\n        \"sql\": {\"SELECT * FROM nonexistent\"},\n    })\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode) // Still 200, error in HTML\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"error\")\n    assert.Contains(t, string(body), \"nonexistent\")\n}\n\nfunc TestQueryExecuteEmpty(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/query\", url.Values{\n        \"sql\": {\"\"},\n    })\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"cannot be empty\")\n}\n\nfunc TestQueryExecuteTooLong(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    longQuery := \"SELECT \" + strings.Repeat(\"x\", 20000)\n    resp, err := http.PostForm(ts.URL+\"/query\", url.Values{\n        \"sql\": {longQuery},\n    })\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"too long\")\n}\n```\n\n## Definition of Done\n- [ ] POST /query handler implemented\n- [ ] Returns partials/results.html on success\n- [ ] Returns partials/error.html on failure\n- [ ] Empty query validation with clear message\n- [ ] Query length limit (10KB)\n- [ ] 30 second query timeout\n- [ ] EXPLAIN checkbox adds EXPLAIN prefix\n- [ ] Result includes column names, rows, duration\n- [ ] TestQueryExecuteSuccess passes\n- [ ] TestQueryExecuteError passes\n- [ ] TestQueryExecuteEmpty passes\n- [ ] TestQueryExecuteTooLong passes\n","status":"closed","priority":1,"issue_type":"task","assignee":"nux","created_at":"2026-01-07T16:55:19.158141-07:00","created_by":"mayor","updated_at":"2026-01-07T17:26:09.938564-07:00","closed_at":"2026-01-07T17:26:09.938564-07:00","close_reason":"Implemented POST /query handler with validation, error handling, and HTML partial responses","dependencies":[{"issue_id":"cdb-5us","depends_on_id":"cdb-m45","type":"blocks","created_at":"2026-01-07T16:56:26.111353-07:00","created_by":"mayor"}]}
{"id":"cdb-5xp","title":"Create SQL query input form","description":"## Problem\nUsers need a form to enter SQL queries for execution.\n\n## Solution\nCreate query.html template with textarea and HTMX-powered submit.\n\n## Implementation\n\n```html\n{{/* templates/query.html */}}\n{{define \"title\"}}Query - claudedb{{end}}\n\n{{define \"content\"}}\n\u003cdiv class=\"query-page\"\u003e\n    \u003ch1\u003eSQL Query\u003c/h1\u003e\n    \n    \u003cform hx-post=\"/query\" \n          hx-target=\"#results\" \n          hx-swap=\"innerHTML\"\n          hx-indicator=\"#loading\"\u003e\n        \n        \u003cdiv class=\"form-group\"\u003e\n            \u003clabel for=\"sql\"\u003eSQL Statement:\u003c/label\u003e\n            \u003ctextarea \n                id=\"sql\" \n                name=\"sql\" \n                rows=\"6\" \n                placeholder=\"SELECT * FROM users;\"\n                required\n            \u003e{{.Query}}\u003c/textarea\u003e\n        \u003c/div\u003e\n        \n        \u003cdiv class=\"form-actions\"\u003e\n            \u003cbutton type=\"submit\" class=\"btn-primary\"\u003eExecute\u003c/button\u003e\n            \u003clabel\u003e\n                \u003cinput type=\"checkbox\" name=\"explain\" value=\"1\"\u003e\n                Show Query Plan\n            \u003c/label\u003e\n        \u003c/div\u003e\n    \u003c/form\u003e\n    \n    \u003cdiv id=\"loading\" class=\"htmx-indicator\"\u003e\n        Executing query...\n    \u003c/div\u003e\n    \n    \u003cdiv id=\"results\"\u003e\n        {{block \"results\" .}}{{end}}\n    \u003c/div\u003e\n\u003c/div\u003e\n{{end}}\n```\n\n```go\n// Handler in internal/web/handlers.go\nfunc (s *Server) handleQueryPage(w http.ResponseWriter, r *http.Request) {\n    data := map[string]interface{}{\n        \"Query\": \"\", // Empty initially, or from query param for bookmarking\n    }\n    \n    if q := r.URL.Query().Get(\"q\"); q != \"\" {\n        data[\"Query\"] = q\n    }\n    \n    renderTemplate(w, \"query.html\", data)\n}\n```\n\n## Files to Create/Modify\n- internal/web/templates/query.html\n- internal/web/handlers.go (add handleQueryPage)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Empty textarea submitted | Show \"Query required\" error |\n| Query in URL (?q=SELECT...) | Pre-populate textarea |\n| Very long query | Textarea should scroll, no truncation |\n| Special characters in query | Properly escaped in HTML |\n| Form submitted without JS | Fallback full page reload works |\n\n## Test Scenarios\n\n```go\nfunc TestQueryPageRenders(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/query\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"\u003ctextarea\")\n    assert.Contains(t, html, \"hx-post=\\\"/query\\\"\")\n    assert.Contains(t, html, \"Execute\")\n}\n\nfunc TestQueryPagePrePopulates(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/query?q=SELECT+1\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"SELECT 1\")\n}\n\nfunc TestQueryPageEscapesHTML(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/query?q=\u003cscript\u003ealert(1)\u003c/script\u003e\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.NotContains(t, string(body), \"\u003cscript\u003ealert\")\n}\n```\n\n## Definition of Done\n- [ ] /query route serves query.html\n- [ ] Textarea for SQL input with placeholder\n- [ ] Execute button with hx-post to /query\n- [ ] Results div targeted by HTMX response\n- [ ] Loading indicator during request\n- [ ] Optional explain checkbox\n- [ ] Query param ?q= pre-populates textarea\n- [ ] TestQueryPageRenders passes\n- [ ] TestQueryPagePrePopulates passes\n- [ ] TestQueryPageEscapesHTML passes\n","status":"closed","priority":1,"issue_type":"task","assignee":"dag","created_at":"2026-01-07T16:55:18.932472-07:00","created_by":"mayor","updated_at":"2026-01-07T17:24:03.742688-07:00","closed_at":"2026-01-07T17:24:03.742688-07:00","close_reason":"Created query.html with textarea, HTMX submit, explain checkbox. Added handleQueryPage handler with ?q= pre-population. All tests pass.","dependencies":[{"issue_id":"cdb-5xp","depends_on_id":"cdb-anc","type":"blocks","created_at":"2026-01-07T16:56:26.071752-07:00","created_by":"mayor"}]}
{"id":"cdb-6ek","title":"Session ended: gt-claudedb-toast","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:27:36.255751-07:00","created_by":"claudedb/polecats/toast","updated_at":"2026-01-07T14:27:36.255751-07:00"}
{"id":"cdb-6fl","title":"Merge: nux-query","description":"branch: polecat/nux-query-handler\ntarget: main\nsource_issue: nux-query\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-nux\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:26:20.704042-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:26:20.704042-07:00"}
{"id":"cdb-6q1","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:42:07.725077-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T14:42:07.725077-07:00"}
{"id":"cdb-6ss","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:25:21.421348-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T16:25:21.421348-07:00"}
{"id":"cdb-70r","title":"ORDER BY + LIMIT optimization","description":"Optimize ORDER BY when combined with LIMIT to avoid full sort.\n\n## Current Behavior\n- executor.go lines 357-374 sort ALL matching rows\n- Then applies LIMIT after sorting\n- Wasteful for 'SELECT ... ORDER BY x LIMIT 10' on 1M rows\n\n## Implementation Options\n1. **Index-ordered scan**: If ORDER BY matches an index, use index scan (naturally sorted)\n2. **Top-K heap**: For LIMIT K, maintain heap of K items instead of full sort\n3. **Push LIMIT into sort**: Stop sorting after K items found\n\n## Files\n- internal/sql/executor/executor.go (lines 357-374)\n- internal/sql/planner/ (detect ORDER BY + LIMIT pattern)\n\n## Acceptance Criteria\n- ORDER BY + LIMIT 10 on 1M rows doesn't sort all 1M\n- If index matches ORDER BY, use index scan order\n- Benchmark shows improvement for small LIMIT values","status":"closed","priority":3,"issue_type":"task","assignee":"claudedb/polecats/capable","created_at":"2026-01-07T12:19:06.184708-07:00","created_by":"mayor","updated_at":"2026-01-07T16:15:48.04857-07:00","closed_at":"2026-01-07T16:15:48.04857-07:00","close_reason":"Implemented heap-based top-K selection for ORDER BY + LIMIT. O(N log K) instead of O(N log N). Tests and benchmark added.","dependencies":[{"issue_id":"cdb-70r","depends_on_id":"cdb-2tp","type":"blocks","created_at":"2026-01-07T12:19:19.681676-07:00","created_by":"mayor"}]}
{"id":"cdb-7bb","title":"Merge: cheedo-mk4ls9je","description":"branch: polecat/cheedo-mk4ls9je\ntarget: main\nsource_issue: cheedo-mk4ls9je\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-cheedo\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T15:47:57.298026-07:00","created_by":"claudedb/polecats/cheedo","updated_at":"2026-01-07T16:09:17.931917-07:00","closed_at":"2026-01-07T16:09:17.931917-07:00","close_reason":"Already merged to main"}
{"id":"cdb-7dc","title":"Merge: nux-results","description":"branch: polecat/nux-results-template\ntarget: main\nsource_issue: nux-results\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-nux\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:31:58.44517-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:31:58.44517-07:00"}
{"id":"cdb-7en","title":"Session ended: gt-claudedb-toast","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:33:31.494225-07:00","created_by":"claudedb/polecats/toast","updated_at":"2026-01-07T17:33:31.494225-07:00"}
{"id":"cdb-7kz","title":"serializeValue missing default case silently corrupts data","description":"## Problem\n\n`serializeValue()` has no default case in its switch statement. Unknown types silently write no value data, causing deserialization to read misaligned garbage.\n\n## Root Cause\n\n**table.go:356-381**:\n```go\nfunc (t *Table) serializeValue(buf *bytes.Buffer, val Value) {\n    buf.WriteByte(byte(val.Type))  // Type written\n    buf.WriteByte(0)               // Null flag written\n    \n    switch val.Type {\n    case parser.TypeInteger:\n        binary.Write(buf, binary.LittleEndian, val.Integer)\n    case parser.TypeReal:\n        // ...\n    case parser.TypeText:\n        // ...\n    case parser.TypeBoolean:\n        // ...\n    // NO DEFAULT CASE!\n    }\n}\n```\n\nIf `val.Type` is `TypeUnknown` or any future type not handled, the type byte and null flag are written but no value bytes follow.\n\n## Impact\n\n- Deserialization reads wrong bytes (misaligned)\n- Silent data corruption\n- Difficult to debug  corruption happens at write time, error appears at read time\n\n## Suggested Fix\n\nChange signature to return error and add default case:\n\n```go\nfunc (t *Table) serializeValue(buf *bytes.Buffer, val Value) error {\n    buf.WriteByte(byte(val.Type))\n    if val.IsNull {\n        buf.WriteByte(1)\n        return nil\n    }\n    buf.WriteByte(0)\n\n    switch val.Type {\n    case parser.TypeInteger:\n        if err := binary.Write(buf, binary.LittleEndian, val.Integer); err != nil {\n            return err\n        }\n    // ... other cases with error handling ...\n    default:\n        return fmt.Errorf(\"unsupported type for serialization: %v\", val.Type)\n    }\n    return nil\n}\n```\n\nThis also addresses the ignored `binary.Write` errors in the same function.\n\n## Files Affected\n\n- internal/table/table.go (serializeValue and its callers)","status":"closed","priority":2,"issue_type":"bug","assignee":"claudedb/polecats/capable","created_at":"2026-01-04T06:26:39.398424-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T15:21:06.111126-07:00","closed_at":"2026-01-07T15:21:06.111126-07:00","close_reason":"Fixed: serializeValue now returns error with default case for unknown types. All binary.Write errors are handled. Tests added."}
{"id":"cdb-8p0","title":"Use B-tree for primary key equality lookups","description":"## Problem\nThe executor always does full table scans even for primary key lookups.\n\n## Solution\nUse query planner output to choose between index lookup and full scan.\n\n## Implementation\n\n```go\nfunc (e *Executor) executeSelect(stmt *parser.SelectStatement) (*Result, error) {\n    tbl, exists := e.tables[stmt.From]\n    if !exists {\n        return nil, fmt.Errorf(\"table %s does not exist\", stmt.From)\n    }\n    \n    // Get plan from planner\n    plan, err := e.planner.Plan(stmt)\n    if err != nil {\n        return nil, fmt.Errorf(\"planning failed: %w\", err)\n    }\n    \n    var rows []table.Row\n    \n    switch plan.Type {\n    case planner.PlanIndexScan:\n        // Single-key lookup\n        keyBytes := predicateToKey(plan.IndexPredicates[0])\n        location, found, err := tbl.GetBTree().Search(keyBytes)\n        if err != nil {\n            return nil, err\n        }\n        if found {\n            row, err := tbl.GetRowByLocation(location)\n            if err != nil {\n                return nil, err\n            }\n            // Apply residual predicates\n            if matchesPredicates(row, plan.ResidualPredicates, tbl.Schema) {\n                rows = append(rows, row)\n            }\n        }\n        \n    case planner.PlanIndexRangeScan:\n        // Range scan via iterator\n        start, end := predicatesToBounds(plan.IndexPredicates)\n        iter := tbl.GetBTree().RangeScan(start, end, storage.ScanOptions{})\n        defer iter.Close()\n        \n        for iter.Next() {\n            row, err := tbl.GetRowByLocation(iter.Value())\n            if err != nil {\n                continue // Skip corrupted rows\n            }\n            if matchesPredicates(row, plan.ResidualPredicates, tbl.Schema) {\n                rows = append(rows, row)\n                if plan.Limit != nil \u0026\u0026 len(rows) \u003e= *plan.Limit {\n                    break\n                }\n            }\n        }\n        if iter.Err() != nil {\n            return nil, iter.Err()\n        }\n        \n    case planner.PlanTableScan:\n        // Full scan (existing behavior)\n        allRows, err := tbl.Scan()\n        if err != nil {\n            return nil, err\n        }\n        for _, row := range allRows {\n            if matchesPredicates(row, plan.ResidualPredicates, tbl.Schema) {\n                rows = append(rows, row)\n            }\n        }\n    }\n    \n    // ... rest of SELECT (ORDER BY, LIMIT, projection)\n}\n```\n\n## Files to Modify\n- internal/sql/executor/executor.go\n\n## Edge Cases\n\n| Case | Query | Expected Behavior |\n|------|-------|-------------------|\n| PK equals literal | `WHERE id = 5` | IndexScan, returns 0 or 1 row |\n| PK not found | `WHERE id = 999` (no such row) | IndexScan, returns 0 rows (not error) |\n| PK + other condition | `WHERE id = 5 AND name = 'x'` | IndexScan, then filter by name |\n| PK range | `WHERE id \u003e 10` | IndexRangeScan |\n| Non-PK column | `WHERE name = 'x'` | TableScan with filter |\n| No WHERE | `SELECT * FROM t` | TableScan, no filter |\n| PK with LIMIT | `WHERE id = 5 LIMIT 1` | IndexScan (LIMIT is no-op for single key) |\n| Type mismatch | `WHERE id = 'five'` | Error or TableScan (depends on parser) |\n| Empty table | `WHERE id = 1` on empty table | IndexScan, returns 0 rows |\n\n## Test Scenarios\n\n```go\nfunc TestExecutorUsesPKIndex(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT\")\n    \n    // Insert test data\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'Alice')\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (2, 'Bob')\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (3, 'Charlie')\"))\n    \n    // Test: PK lookup should use index\n    result, err := exec.Execute(parseSQL(\"SELECT * FROM users WHERE id = 2\"))\n    require.NoError(t, err)\n    assert.Equal(t, 1, len(result.Rows))\n    assert.Equal(t, \"Bob\", result.Rows[0][1].Text)\n}\n\nfunc TestExecutorPKNotFound(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT\")\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'Alice')\"))\n    \n    result, err := exec.Execute(parseSQL(\"SELECT * FROM users WHERE id = 999\"))\n    require.NoError(t, err)\n    assert.Equal(t, 0, len(result.Rows)) // Not error, just empty\n}\n\nfunc TestExecutorMixedPredicates(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT, age INTEGER\")\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'Alice', 30)\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (2, 'Bob', 25)\"))\n    \n    // PK match but residual fails\n    result, err := exec.Execute(parseSQL(\n        \"SELECT * FROM users WHERE id = 1 AND age = 99\"))\n    require.NoError(t, err)\n    assert.Equal(t, 0, len(result.Rows))\n    \n    // PK match and residual passes\n    result, err = exec.Execute(parseSQL(\n        \"SELECT * FROM users WHERE id = 1 AND age = 30\"))\n    require.NoError(t, err)\n    assert.Equal(t, 1, len(result.Rows))\n}\n```\n\n## Performance Verification\n\n```go\nfunc BenchmarkPKLookup(b *testing.B) {\n    exec := setupExecutorWithTable(b, \"users\", \"id INTEGER PRIMARY KEY, name TEXT\")\n    \n    // Insert 10,000 rows\n    for i := 0; i \u003c 10000; i++ {\n        exec.Execute(parseSQL(fmt.Sprintf(\n            \"INSERT INTO users VALUES (%d, 'User%d')\", i, i)))\n    }\n    \n    stmt := parseSQL(\"SELECT * FROM users WHERE id = 5000\")\n    \n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        exec.Execute(stmt)\n    }\n    // Should be O(log n) ~ 14 comparisons, not O(n) = 10000 comparisons\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Executor uses planner\ngrep -n \"planner.Plan\" internal/sql/executor/executor.go\n# Expected: Shows planner being called in executeSelect\n\n# 2. Switch on plan type\ngrep -n \"switch plan.Type\" internal/sql/executor/executor.go\n# Expected: Shows switch statement with PlanIndexScan case\n\n# 3. Uses GetRowByLocation\ngrep -n \"GetRowByLocation\" internal/sql/executor/executor.go\n# Expected: Shows call after B-tree Search\n\n# 4. Tests pass\ngo test ./internal/sql/executor/... -v -run TestExecutor\n# Expected: All PASS\n\n# 5. Benchmark shows improvement\ngo test ./internal/sql/executor/... -bench=BenchmarkPKLookup -benchtime=1s\n# Expected: Fast (microseconds per op, not milliseconds)\n```\n\n## Definition of Done\n- [ ] `executeSelect` calls `planner.Plan()` to get execution plan\n- [ ] Switch statement handles `PlanIndexScan`, `PlanIndexRangeScan`, `PlanTableScan`\n- [ ] `PlanIndexScan` uses `btree.Search()` + `GetRowByLocation()`\n- [ ] Residual predicates applied after row fetch\n- [ ] `TestExecutorUsesPKIndex` passes: correct row returned\n- [ ] `TestExecutorPKNotFound` passes: empty result, no error\n- [ ] `TestExecutorMixedPredicates` passes: residual filtering works\n- [ ] Benchmark shows O(log n) behavior for PK lookups","status":"closed","priority":1,"issue_type":"feature","assignee":"claudedb/polecats/dementus","created_at":"2026-01-05T05:38:48.750693-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T15:12:02.055837-07:00","closed_at":"2026-01-07T15:12:02.055837-07:00","close_reason":"Already implemented and merged to main","dependencies":[{"issue_id":"cdb-8p0","depends_on_id":"cdb-5jc","type":"blocks","created_at":"2026-01-05T05:51:10.608296-07:00","created_by":"cabewaldrop"},{"issue_id":"cdb-8p0","depends_on_id":"cdb-goh","type":"blocks","created_at":"2026-01-05T05:51:15.852079-07:00","created_by":"cabewaldrop"}]}
{"id":"cdb-90c","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:06:32.885157-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T16:06:32.885157-07:00"}
{"id":"cdb-931","title":"Range scan support for inequality operators","description":"Enable index-backed range scans for inequality operators (\u003e, \u003c, \u003e=, \u003c=, BETWEEN).\n\n## Current State\n- B+ tree leaf nodes are linked (standard B+ tree design)\n- Only equality lookups possible\n- Inequalities always do full scan\n\n## Implementation\n1. Add BTree.RangeSearch(minKey, maxKey) method\n2. Traverse to start leaf, follow links to end\n3. Query planner detects range patterns in WHERE\n4. Generate RangeScan plan instead of FullTableScan\n\n## Patterns to Detect\n- column \u003e value\n- column \u003c value\n- column \u003e= value\n- column \u003c= value\n- column BETWEEN low AND high\n\n## Files\n- internal/storage/btree.go (RangeSearch method)\n- internal/sql/planner/ (range pattern detection)\n\n## Acceptance Criteria\n- WHERE age \u003e 30 uses range scan if index exists\n- BETWEEN uses single range scan\n- Page access proportional to result set, not table size","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T12:19:05.994904-07:00","created_by":"mayor","updated_at":"2026-01-07T14:05:19.91024-07:00","closed_at":"2026-01-07T12:21:33.136725-07:00","close_reason":"Superseded by existing claude-db-loe (Implement B-tree range scans) which has iterator design, edge cases, and depends on claude-db-a0f (sibling pointers)","dependencies":[{"issue_id":"cdb-931","depends_on_id":"cdb-2tp","type":"blocks","created_at":"2026-01-07T12:19:19.642926-07:00","created_by":"mayor"}]}
{"id":"cdb-9hz","title":"Data Manipulation UI","description":"Create tables, insert rows, update/delete data through web forms.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T16:52:48.731586-07:00","created_by":"mayor","updated_at":"2026-01-07T16:52:48.731586-07:00","dependencies":[{"issue_id":"cdb-9hz","depends_on_id":"cdb-e33","type":"blocks","created_at":"2026-01-07T16:56:09.323134-07:00","created_by":"mayor"},{"issue_id":"cdb-9hz","depends_on_id":"cdb-pbn","type":"blocks","created_at":"2026-01-07T16:56:09.358262-07:00","created_by":"mayor"},{"issue_id":"cdb-9hz","depends_on_id":"cdb-9kl","type":"blocks","created_at":"2026-01-07T16:56:34.79368-07:00","created_by":"mayor"},{"issue_id":"cdb-9hz","depends_on_id":"cdb-4js","type":"blocks","created_at":"2026-01-07T16:56:34.832841-07:00","created_by":"mayor"},{"issue_id":"cdb-9hz","depends_on_id":"cdb-1f7","type":"blocks","created_at":"2026-01-07T16:56:34.874074-07:00","created_by":"mayor"},{"issue_id":"cdb-9hz","depends_on_id":"cdb-mx2","type":"blocks","created_at":"2026-01-07T16:56:34.9182-07:00","created_by":"mayor"}]}
{"id":"cdb-9kl","title":"Create table form and handler","description":"## Problem\nUsers need to create new tables through the UI without writing SQL.\n\n## Solution\nForm at /tables/new to define table schema and generate CREATE TABLE.\n\n## Implementation\n\n```html\n{{/* templates/table_new.html */}}\n{{define \"title\"}}Create Table - claudedb{{end}}\n\n{{define \"content\"}}\n\u003cdiv class=\"create-table-page\"\u003e\n    \u003cnav class=\"breadcrumb\"\u003e\n        \u003ca href=\"/tables\"\u003eTables\u003c/a\u003e / \u003cspan\u003eCreate\u003c/span\u003e\n    \u003c/nav\u003e\n    \n    \u003ch1\u003eCreate Table\u003c/h1\u003e\n    \n    \u003cform hx-post=\"/tables\" hx-target=\"#result\" id=\"create-table-form\"\u003e\n        \u003cdiv class=\"form-group\"\u003e\n            \u003clabel for=\"table-name\"\u003eTable Name:\u003c/label\u003e\n            \u003cinput type=\"text\" id=\"table-name\" name=\"table_name\" \n                   pattern=\"[a-zA-Z_][a-zA-Z0-9_]*\" \n                   required\n                   placeholder=\"my_table\"\u003e\n            \u003csmall\u003eLetters, numbers, underscores. Must start with letter or underscore.\u003c/small\u003e\n        \u003c/div\u003e\n        \n        \u003cdiv class=\"columns-section\"\u003e\n            \u003ch2\u003eColumns\u003c/h2\u003e\n            \u003cdiv id=\"columns-container\"\u003e\n                \u003c!-- Column rows added dynamically --\u003e\n            \u003c/div\u003e\n            \u003cbutton type=\"button\" onclick=\"addColumn()\" class=\"btn-secondary\"\u003e\n                + Add Column\n            \u003c/button\u003e\n        \u003c/div\u003e\n        \n        \u003cdiv class=\"form-actions\"\u003e\n            \u003cbutton type=\"submit\" class=\"btn-primary\"\u003eCreate Table\u003c/button\u003e\n            \u003ca href=\"/tables\" class=\"btn\"\u003eCancel\u003c/a\u003e\n        \u003c/div\u003e\n    \u003c/form\u003e\n    \n    \u003cdiv id=\"result\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ctemplate id=\"column-template\"\u003e\n    \u003cdiv class=\"column-row\"\u003e\n        \u003cinput type=\"text\" name=\"col_name[]\" placeholder=\"column_name\" required\u003e\n        \u003cselect name=\"col_type[]\" required\u003e\n            \u003coption value=\"INTEGER\"\u003eINTEGER\u003c/option\u003e\n            \u003coption value=\"TEXT\"\u003eTEXT\u003c/option\u003e\n            \u003coption value=\"REAL\"\u003eREAL\u003c/option\u003e\n            \u003coption value=\"BLOB\"\u003eBLOB\u003c/option\u003e\n        \u003c/select\u003e\n        \u003clabel\u003e\u003cinput type=\"checkbox\" name=\"col_pk[]\" value=\"1\"\u003e PK\u003c/label\u003e\n        \u003clabel\u003e\u003cinput type=\"checkbox\" name=\"col_notnull[]\" value=\"1\"\u003e NOT NULL\u003c/label\u003e\n        \u003cbutton type=\"button\" onclick=\"removeColumn(this)\" class=\"btn-small\"\u003eRemove\u003c/button\u003e\n    \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nfunction addColumn() {\n    const template = document.getElementById(\"column-template\");\n    const container = document.getElementById(\"columns-container\");\n    const clone = template.content.cloneNode(true);\n    container.appendChild(clone);\n}\nfunction removeColumn(btn) {\n    btn.closest(\".column-row\").remove();\n}\n// Add first column by default\ndocument.addEventListener(\"DOMContentLoaded\", addColumn);\n\u003c/script\u003e\n{{end}}\n```\n\n```go\nfunc (s *Server) handleCreateTable(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodGet {\n        renderTemplate(w, \"table_new.html\", nil)\n        return\n    }\n    \n    // POST: Create the table\n    tableName := r.FormValue(\"table_name\")\n    \n    // Validate table name\n    if !isValidIdentifier(tableName) {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Invalid table name. Use letters, numbers, underscores.\",\n        })\n        return\n    }\n    \n    // Build CREATE TABLE statement\n    colNames := r.Form[\"col_name[]\"]\n    colTypes := r.Form[\"col_type[]\"]\n    colPKs := r.Form[\"col_pk[]\"]\n    colNotNulls := r.Form[\"col_notnull[]\"]\n    \n    if len(colNames) == 0 {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"At least one column is required.\",\n        })\n        return\n    }\n    \n    var columns []string\n    for i, name := range colNames {\n        if !isValidIdentifier(name) {\n            renderTemplate(w, \"partials/error.html\", map[string]string{\n                \"Error\": fmt.Sprintf(\"Invalid column name: %s\", name),\n            })\n            return\n        }\n        \n        col := fmt.Sprintf(\"%s %s\", name, colTypes[i])\n        if contains(colPKs, fmt.Sprintf(\"%d\", i)) {\n            col += \" PRIMARY KEY\"\n        }\n        if contains(colNotNulls, fmt.Sprintf(\"%d\", i)) {\n            col += \" NOT NULL\"\n        }\n        columns = append(columns, col)\n    }\n    \n    sql := fmt.Sprintf(\"CREATE TABLE %s (%s)\", tableName, strings.Join(columns, \", \"))\n    \n    exec := GetExecutor(r)\n    _, err := exec.Execute(sql)\n    if err != nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": err.Error(),\n            \"Query\": sql,\n        })\n        return\n    }\n    \n    // Redirect to new table page\n    w.Header().Set(\"HX-Redirect\", \"/tables/\"+tableName)\n    w.WriteHeader(200)\n}\n\nfunc isValidIdentifier(s string) bool {\n    if s == \"\" {\n        return false\n    }\n    matched, _ := regexp.MatchString(`^[a-zA-Z_][a-zA-Z0-9_]*$`, s)\n    return matched\n}\n```\n\n## Files to Create\n- internal/web/templates/table_new.html\n- internal/web/handlers.go (handleCreateTable)\n- internal/web/validation.go (isValidIdentifier)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Empty table name | Validation error |\n| Table name starts with number | Validation error |\n| Reserved SQL keyword as name | Allow (but warn?) or reject |\n| Table already exists | Show SQL error \"table already exists\" |\n| No columns defined | Validation error |\n| Column name duplicate | SQL error (duplicate column) |\n| Multiple PRIMARY KEY | SQL error (multiple PKs) |\n| All NOT NULL, no defaults | Valid, but inserting requires all columns |\n\n## Test Scenarios\n\n```go\nfunc TestCreateTableFormRenders(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/new\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"Create Table\")\n    assert.Contains(t, html, \"table_name\")\n    assert.Contains(t, html, \"Add Column\")\n}\n\nfunc TestCreateTableSuccess(t *testing.T) {\n    exec := setupTestExecutor(t)\n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/tables\", url.Values{\n        \"table_name\":    {\"users\"},\n        \"col_name[]\":    {\"id\", \"name\"},\n        \"col_type[]\":    {\"INTEGER\", \"TEXT\"},\n        \"col_pk[]\":      {\"0\"},\n        \"col_notnull[]\": {\"1\"},\n    })\n    require.NoError(t, err)\n    \n    // Check table was created\n    tables := exec.ListTables()\n    assert.Contains(t, tables, \"users\")\n}\n\nfunc TestCreateTableInvalidName(t *testing.T) {\n    exec := setupTestExecutor(t)\n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.PostForm(ts.URL+\"/tables\", url.Values{\n        \"table_name\": {\"123invalid\"},\n        \"col_name[]\": {\"id\"},\n        \"col_type[]\": {\"INTEGER\"},\n    })\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"Invalid table name\")\n}\n\nfunc TestIsValidIdentifier(t *testing.T) {\n    tests := []struct {\n        input string\n        valid bool\n    }{\n        {\"users\", true},\n        {\"user_table\", true},\n        {\"_private\", true},\n        {\"123start\", false},\n        {\"has-dash\", false},\n        {\"has space\", false},\n        {\"\", false},\n    }\n    for _, tt := range tests {\n        assert.Equal(t, tt.valid, isValidIdentifier(tt.input), tt.input)\n    }\n}\n```\n\n## Definition of Done\n- [ ] GET /tables/new shows form\n- [ ] POST /tables creates table from form data\n- [ ] Table name validation (pattern: [a-zA-Z_][a-zA-Z0-9_]*)\n- [ ] Column name validation\n- [ ] Dynamic add/remove column UI\n- [ ] Type dropdown (INTEGER, TEXT, REAL, BLOB)\n- [ ] PRIMARY KEY checkbox\n- [ ] NOT NULL checkbox  \n- [ ] Error display for invalid input\n- [ ] Error display for SQL errors\n- [ ] Redirect to new table on success\n- [ ] TestCreateTableFormRenders passes\n- [ ] TestCreateTableSuccess passes\n- [ ] TestCreateTableInvalidName passes\n- [ ] TestIsValidIdentifier passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"furiosa","created_at":"2026-01-07T16:55:40.374765-07:00","created_by":"mayor","updated_at":"2026-01-07T17:33:21.122358-07:00","closed_at":"2026-01-07T17:33:21.122358-07:00","close_reason":"Implemented create table form at /tables/new with validation, handlers, and tests"}
{"id":"cdb-9qb","title":"Session ended: gt-claudedb-nux","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:32:27.009654-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:32:27.009654-07:00"}
{"id":"cdb-9ym","title":"Merge: dementus-mk4icxa6","description":"branch: polecat/dementus-mk4icxa6\ntarget: main\nsource_issue: dementus-mk4icxa6\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-dementus\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:33:25.189179-07:00","created_by":"claudedb/polecats/dementus","updated_at":"2026-01-07T17:33:25.189179-07:00"}
{"id":"cdb-a0f","title":"Add leaf sibling pointers to B-tree for efficient range scans","description":"## Problem\nThe current B+ tree has no sibling pointers between leaf nodes. Range scans must traverse up and down the tree for each leaf, making them O(k log n) instead of O(log n + k).\n\n## Solution\nAdd next/prev sibling pointers to leaf nodes:\n\n```go\ntype BTreeNode struct {\n    pageID      uint32\n    isLeaf      bool\n    numKeys     uint16\n    keys        [][]byte\n    values      []uint64\n    children    []uint32\n    nextLeaf    uint32  // 0 if rightmost leaf\n    prevLeaf    uint32  // 0 if leftmost leaf\n}\n```\n\n## Implementation Details\n\n### Serialization Format Change\n```\nExisting: [isLeaf:1][numKeys:2][numChildren:2][keys...][values/children...]\nNew:      [isLeaf:1][numKeys:2][numChildren:2][nextLeaf:4][prevLeaf:4][keys...][values/children...]\n```\n\n### Split Maintenance\nWhen splitting a leaf node:\n```go\nfunc (bt *BTree) splitChild(...) {\n    // Before: left \u003c-\u003e right_neighbor\n    // After:  left \u003c-\u003e new_sibling \u003c-\u003e right_neighbor\n    \n    sibling.nextLeaf = child.nextLeaf\n    sibling.prevLeaf = child.pageID\n    child.nextLeaf = sibling.pageID\n    \n    // Update right neighbor's prevLeaf\n    if sibling.nextLeaf != 0 {\n        rightNeighbor := loadNode(sibling.nextLeaf)\n        rightNeighbor.prevLeaf = sibling.pageID\n        saveNode(rightNeighbor)\n    }\n}\n```\n\n## Files to Modify\n- internal/storage/btree.go\n\n## Edge Cases\n\n| Case | Scenario | Expected Behavior |\n|------|----------|-------------------|\n| Single-node tree | Root is the only leaf | nextLeaf=0, prevLeaf=0 |\n| First split | Root splits into two leaves | left.nextLeaf=right, right.prevLeaf=left, both ends=0 |\n| Middle split | Split a middle leaf | Chain: ...prev \u003c-\u003e left \u003c-\u003e new \u003c-\u003e next... |\n| Leftmost leaf | First leaf in chain | prevLeaf=0, nextLeaf=second_leaf |\n| Rightmost leaf | Last leaf in chain | prevLeaf=second_to_last, nextLeaf=0 |\n| Load old format | B-tree without sibling fields | nextLeaf=0, prevLeaf=0 (graceful default) |\n\n## Migration Strategy\nFor existing B-trees created before this change:\n```go\nfunc deserializeNode(page *Page) (*BTreeNode, error) {\n    // ... read existing fields ...\n    \n    // Check if sibling fields exist (new format)\n    if buf.Len() \u003e= 8 {\n        binary.Read(buf, binary.LittleEndian, \u0026node.nextLeaf)\n        binary.Read(buf, binary.LittleEndian, \u0026node.prevLeaf)\n    } else {\n        // Old format: default to no siblings\n        node.nextLeaf = 0\n        node.prevLeaf = 0\n    }\n}\n```\n\n## Test Scenarios\n\n```go\nfunc TestSiblingPointersAfterInserts(t *testing.T) {\n    bt := createEmptyBTree(t)\n    \n    // Insert enough keys to cause multiple splits\n    for i := 0; i \u003c 250; i++ {\n        bt.Insert(intToBytes(i), uint64(i))\n    }\n    \n    // Verify sibling chain by traversing from leftmost to rightmost\n    leftmost := findLeftmostLeaf(bt)\n    assert.Equal(t, uint32(0), leftmost.prevLeaf, \"leftmost should have no prev\")\n    \n    visited := 0\n    current := leftmost\n    var lastKey []byte\n    for current != nil {\n        // Verify keys are in order across siblings\n        if lastKey != nil {\n            assert.True(t, bytes.Compare(lastKey, current.keys[0]) \u003c 0,\n                \"keys should be ordered across siblings\")\n        }\n        if len(current.keys) \u003e 0 {\n            lastKey = current.keys[len(current.keys)-1]\n        }\n        \n        visited++\n        if current.nextLeaf == 0 {\n            assert.Equal(t, uint32(0), current.nextLeaf, \"rightmost should have no next\")\n            break\n        }\n        current = loadNode(current.nextLeaf)\n    }\n    \n    // Count should match number of leaves\n    assert.True(t, visited \u003e= 3, \"should have multiple leaves after 250 inserts\")\n}\n\nfunc TestSiblingChainIntegrity(t *testing.T) {\n    bt := createBTreeWith100Keys(t)\n    \n    // Traverse forward and count\n    forwardCount := countLeavesForward(bt)\n    \n    // Traverse backward and count\n    backwardCount := countLeavesBackward(bt)\n    \n    assert.Equal(t, forwardCount, backwardCount, \"forward and backward traversal should match\")\n    \n    // Verify bidirectional links\n    current := findLeftmostLeaf(bt)\n    for current.nextLeaf != 0 {\n        next := loadNode(current.nextLeaf)\n        assert.Equal(t, current.pageID, next.prevLeaf, \n            \"next.prevLeaf should point back to current\")\n        current = next\n    }\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Struct has new fields\ngrep -A5 \"type BTreeNode struct\" internal/storage/btree.go | grep -E \"nextLeaf|prevLeaf\"\n# Expected: Both fields present\n\n# 2. Serialization includes siblings\ngrep -n \"nextLeaf\" internal/storage/btree.go | wc -l\n# Expected: At least 4 occurrences (struct, serialize, deserialize, split)\n\n# 3. Split maintains siblings\ngrep -B2 -A5 \"sibling.nextLeaf\" internal/storage/btree.go\n# Expected: Shows sibling chain maintenance code\n\n# 4. All existing tests still pass\ngo test ./internal/storage/... -v -run TestBTree\n# Expected: All PASS\n\n# 5. New sibling tests pass\ngo test ./internal/storage/... -v -run TestSibling\n# Expected: All PASS\n```\n\n## Definition of Done\n- [ ] `BTreeNode` struct has `nextLeaf uint32` and `prevLeaf uint32` fields\n- [ ] `serializeNode` writes sibling pointers (8 extra bytes)\n- [ ] `deserializeNode` reads sibling pointers (with backward compatibility)\n- [ ] `splitChild` maintains sibling chain (updates 3 nodes: left, new, right_neighbor)\n- [ ] `TestSiblingPointersAfterInserts` passes: forward traversal visits all leaves in order\n- [ ] `TestSiblingChainIntegrity` passes: prev/next pointers are bidirectional\n- [ ] All existing `TestBTree*` tests still pass (no regression)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-05T05:48:54.324651-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:05:19.911295-07:00","closed_at":"2026-01-07T13:17:11.854707-07:00","close_reason":"Implemented by slit in commit 0b4d56c: Add leaf sibling pointers to B-tree for efficient range scans"}
{"id":"cdb-abj","title":"Session ended: gt-claudedb-rictus","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:32:22.19165-07:00","created_by":"claudedb/polecats/rictus","updated_at":"2026-01-07T17:32:22.19165-07:00"}
{"id":"cdb-acl","title":"Merge: toast-mk4ivone","description":"branch: polecat/toast-mk4ivone\ntarget: main\nsource_issue: toast-mk4ivone\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-toast\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:33:17.599474-07:00","created_by":"claudedb/polecats/toast","updated_at":"2026-01-07T17:33:17.599474-07:00"}
{"id":"cdb-akh","title":"Merge: rictus-mk4hqgkf","description":"branch: polecat/rictus-mk4hqgkf\ntarget: main\nsource_issue: rictus-mk4hqgkf\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-rictus\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:32:08.798689-07:00","created_by":"claudedb/polecats/rictus","updated_at":"2026-01-07T17:32:08.798689-07:00"}
{"id":"cdb-anc","title":"Create base HTML template with HTMX","description":"## Problem\nNeed a base HTML template that all pages extend, with HTMX loaded for dynamic interactions.\n\n## Solution\nCreate templates/base.html using Go html/template with define/block structure.\n\n## Implementation\n\n```html\n{{/* templates/base.html */}}\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003e{{block \"title\" .}}claudedb{{end}}\u003c/title\u003e\n    \u003cscript src=\"/static/htmx.min.js\"\u003e\u003c/script\u003e\n    \u003clink rel=\"stylesheet\" href=\"/static/style.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cnav class=\"navbar\"\u003e\n        \u003ca href=\"/\" class=\"brand\"\u003eclaudedb\u003c/a\u003e\n        \u003cul\u003e\n            \u003cli\u003e\u003ca href=\"/query\"\u003eQuery\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/tables\"\u003eTables\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n    \u003c/nav\u003e\n    \n    \u003cmain class=\"container\"\u003e\n        {{block \"content\" .}}{{end}}\n    \u003c/main\u003e\n    \n    \u003cfooter\u003e\n        \u003cp\u003eclaudedb web interface\u003c/p\u003e\n    \u003c/footer\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n```go\n// internal/web/templates.go\npackage web\n\nimport (\n    \"embed\"\n    \"html/template\"\n    \"io\"\n)\n\n//go:embed templates/*\nvar templateFS embed.FS\n\nvar templates *template.Template\n\nfunc init() {\n    templates = template.Must(template.ParseFS(templateFS, \"templates/*.html\"))\n}\n\nfunc renderTemplate(w io.Writer, name string, data interface{}) error {\n    return templates.ExecuteTemplate(w, name, data)\n}\n```\n\n## Files to Create\n- internal/web/templates/base.html\n- internal/web/templates.go (template loader)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Missing block | Render empty (no error) |\n| Template not found | Clear error, dont panic |\n| Nil data passed | Render without data |\n| HTML in data | Auto-escaped by html/template |\n| Large page content | Stream response, dont buffer all |\n\n## Test Scenarios\n\n```go\nfunc TestBaseTemplateRenders(t *testing.T) {\n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"base.html\", nil)\n    require.NoError(t, err)\n    \n    html := buf.String()\n    assert.Contains(t, html, \"\u003c!DOCTYPE html\u003e\")\n    assert.Contains(t, html, \"htmx.min.js\")\n    assert.Contains(t, html, \"\u003cnav\")\n}\n\nfunc TestTemplateEscapesHTML(t *testing.T) {\n    data := map[string]string{\"Title\": \"\u003cscript\u003ealert(1)\u003c/script\u003e\"}\n    var buf bytes.Buffer\n    err := renderTemplate(\u0026buf, \"base.html\", data)\n    require.NoError(t, err)\n    \n    assert.NotContains(t, buf.String(), \"\u003cscript\u003ealert\")\n    assert.Contains(t, buf.String(), \"\u0026lt;script\u0026gt;\")\n}\n```\n\n## Definition of Done\n- [ ] templates/base.html exists with HTML5 structure\n- [ ] HTMX script tag included\n- [ ] Navigation bar with Query and Tables links\n- [ ] templates.go with embed.FS and renderTemplate function\n- [ ] TestBaseTemplateRenders passes\n- [ ] TestTemplateEscapesHTML passes\n- [ ] Child templates can extend base with {{define \"content\"}}\n","status":"closed","priority":1,"issue_type":"task","assignee":"dag","created_at":"2026-01-07T16:53:05.748313-07:00","created_by":"mayor","updated_at":"2026-01-07T17:19:37.806659-07:00","closed_at":"2026-01-07T17:19:37.806659-07:00","close_reason":"Created base.html template with HTMX, navbar, content block. Created templates.go with embed.FS and RenderTemplate function. All tests pass.","dependencies":[{"issue_id":"cdb-anc","depends_on_id":"cdb-4i4","type":"blocks","created_at":"2026-01-07T16:56:17.21267-07:00","created_by":"mayor"}]}
{"id":"cdb-au8","title":"Add basic table/index statistics for query planning","description":"## Problem\nWithout statistics, the query planner cannot make informed decisions about which access path is best.\n\n## Solution\nTrack row counts and provide basic cardinality estimates.\n\n```go\ntype TableStats struct {\n    RowCount     int64     // Maintained on INSERT/DELETE\n    PageCount    int       // Number of data pages\n    LastAnalyzed time.Time // When ANALYZE was run\n}\n\ntype IndexStats struct {\n    DistinctKeys int64  // Approximate distinct key count\n    LeafPages    int    // Number of leaf pages in B-tree\n    TreeHeight   int    // B-tree depth\n}\n```\n\n## Implementation\n\n### Maintain RowCount\n```go\nfunc (t *Table) Insert(values []Value) (uint64, error) {\n    // ... existing insert logic ...\n    t.stats.RowCount++\n    return rowID, nil\n}\n\nfunc (t *Table) Delete(filter func(Row) bool) (int, error) {\n    // ... delete logic ...\n    t.stats.RowCount -= deletedCount\n    return deletedCount, nil\n}\n```\n\n### ANALYZE Command\n```sql\nANALYZE users;  -- Refresh statistics for 'users' table\nANALYZE;        -- Refresh all tables\n```\n\n```go\nfunc (e *Executor) executeAnalyze(tableName string) error {\n    tbl := e.tables[tableName]\n    \n    // Count rows (could sample for large tables)\n    rows, _ := tbl.Scan()\n    tbl.stats.RowCount = int64(len(rows))\n    tbl.stats.PageCount = len(tbl.dataPageIDs)\n    tbl.stats.LastAnalyzed = time.Now()\n    \n    // For each index, estimate distinct keys\n    for _, idx := range tbl.indexes {\n        keys, _, _ := idx.btree.Scan()\n        distinct := countDistinct(keys)\n        idx.stats.DistinctKeys = distinct\n        idx.stats.TreeHeight = measureTreeHeight(idx.btree)\n    }\n    \n    return e.catalog.SaveStats(tableName, tbl.stats)\n}\n```\n\n### Selectivity Estimation\n```go\nfunc (p *Planner) estimateSelectivity(pred Predicate, stats *TableStats) float64 {\n    switch pred.Operator {\n    case OpEq:\n        // Equality: assume uniform distribution\n        // selectivity = 1 / distinctValues\n        if stats.DistinctKeys \u003e 0 {\n            return 1.0 / float64(stats.DistinctKeys)\n        }\n        return 0.1 // Default 10%\n        \n    case OpLt, OpLe, OpGt, OpGe:\n        // Range: assume 30% selectivity (conservative)\n        return 0.3\n        \n    case OpNe:\n        // Not equal: 1 - equality selectivity\n        return 1.0 - p.estimateSelectivity(Predicate{Operator: OpEq}, stats)\n        \n    default:\n        return 0.5\n    }\n}\n\nfunc (p *Planner) estimateRows(plan *QueryPlan, stats *TableStats) float64 {\n    rows := float64(stats.RowCount)\n    for _, pred := range plan.IndexPredicates {\n        rows *= p.estimateSelectivity(pred, stats)\n    }\n    for _, pred := range plan.ResidualPredicates {\n        rows *= p.estimateSelectivity(pred, stats)\n    }\n    return math.Max(1, rows) // At least 1 row estimated\n}\n```\n\n## Files to Modify\n- internal/table/table.go (TableStats, maintain counts)\n- internal/catalog/catalog.go (persist stats)\n- internal/sql/parser/parser.go (ANALYZE statement)\n- internal/sql/executor/executor.go (executeAnalyze)\n- internal/sql/planner/planner.go (use stats)\n\n## Edge Cases\n\n| Case | Scenario | Expected Behavior |\n|------|----------|-------------------|\n| Empty table | RowCount=0 | Estimates return 0 or 1 rows |\n| No ANALYZE run | Stats not initialized | Use defaults (10% selectivity) |\n| After mass delete | RowCount might be stale | ANALYZE refreshes count |\n| Very skewed data | 99% of rows have same value | Estimates may be off (acceptable) |\n| NULL values | Column with many NULLs | Not specially handled in v1 |\n| Concurrent DML | INSERT during ANALYZE | Approximate count acceptable |\n\n## Test Scenarios\n\n```go\nfunc TestRowCountMaintained(t *testing.T) {\n    tbl := createTestTable(t)\n    assert.Equal(t, int64(0), tbl.Stats().RowCount)\n    \n    tbl.Insert(testRow1)\n    assert.Equal(t, int64(1), tbl.Stats().RowCount)\n    \n    tbl.Insert(testRow2)\n    tbl.Insert(testRow3)\n    assert.Equal(t, int64(3), tbl.Stats().RowCount)\n}\n\nfunc TestAnalyzeCommand(t *testing.T) {\n    exec := setupExecutorWithData(t, \"users\", 100) // 100 rows\n    \n    // Stats should be available after ANALYZE\n    _, err := exec.Execute(parseSQL(\"ANALYZE users\"))\n    require.NoError(t, err)\n    \n    tbl, _ := exec.GetTable(\"users\")\n    assert.Equal(t, int64(100), tbl.Stats().RowCount)\n    assert.True(t, tbl.Stats().LastAnalyzed.After(time.Now().Add(-time.Minute)))\n}\n\nfunc TestSelectivityEstimation(t *testing.T) {\n    planner := setupPlanner(t)\n    stats := \u0026TableStats{RowCount: 1000}\n    indexStats := \u0026IndexStats{DistinctKeys: 100}\n    \n    // Equality: 1/100 = 1%\n    sel := planner.estimateSelectivity(\n        Predicate{Operator: OpEq}, stats, indexStats)\n    assert.InDelta(t, 0.01, sel, 0.001)\n    \n    // Range: 30% default\n    sel = planner.estimateSelectivity(\n        Predicate{Operator: OpGt}, stats, indexStats)\n    assert.InDelta(t, 0.3, sel, 0.01)\n}\n\nfunc TestPlannerUsesStats(t *testing.T) {\n    // Table with 10000 rows, index with 100 distinct values\n    planner := setupPlannerWithStats(t, 10000, 100)\n    \n    plan, _ := planner.Plan(parseSelect(\"SELECT * FROM t WHERE id = 5\"))\n    \n    // Should estimate ~100 rows (10000 / 100 distinct)\n    assert.InDelta(t, 100.0, plan.EstimatedRows, 20.0)\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. TableStats struct exists\ngrep -n \"type TableStats struct\" internal/table/table.go\n# Expected: Shows struct with RowCount field\n\n# 2. RowCount updated on Insert\ngrep -B2 -A2 \"stats.RowCount++\" internal/table/table.go\n# Expected: Shows increment in Insert method\n\n# 3. ANALYZE parses\ngrep -n \"ANALYZE\" internal/sql/parser/parser.go\n# Expected: Shows ANALYZE token handling\n\n# 4. Stats persisted to catalog\ngrep -n \"SaveStats\\|LoadStats\" internal/catalog/catalog.go\n# Expected: Shows persistence methods\n\n# 5. Tests pass\ngo test ./... -v -run \"TestRowCount\\|TestAnalyze\\|TestSelectivity\"\n# Expected: All PASS\n```\n\n## Definition of Done\n- [ ] `TableStats` struct with `RowCount`, `PageCount`, `LastAnalyzed`\n- [ ] `RowCount` incremented on `Insert()`, decremented on `Delete()`\n- [ ] `ANALYZE tablename` SQL command parses and executes\n- [ ] Stats persisted in catalog (survive restart)\n- [ ] `Planner.estimateSelectivity()` uses stats for cost estimation\n- [ ] `QueryPlan.EstimatedRows` populated based on stats\n- [ ] `TestRowCountMaintained` passes\n- [ ] `TestAnalyzeCommand` passes\n- [ ] `TestPlannerUsesStats` passes","status":"closed","priority":3,"issue_type":"feature","assignee":"claudedb/polecats/furiosa","created_at":"2026-01-05T05:48:59.577991-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T16:19:41.272962-07:00","closed_at":"2026-01-07T16:19:41.272962-07:00","close_reason":"Implemented table statistics with ANALYZE command and selectivity estimation"}
{"id":"cdb-b0e","title":"Session ended: gt-claudedb-capable","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:11:55.595598-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T17:11:55.595598-07:00"}
{"id":"cdb-br5","title":"Session ended: gt-claudedb-capable","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:23:29.912197-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T15:23:29.912197-07:00"}
{"id":"cdb-bry","title":"Session ended: gt-claudedb-nux","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:26:45.841673-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:26:45.841673-07:00"}
{"id":"cdb-c0z","title":"Document binary layouts for all storage structures","description":"Create comprehensive documentation for all binary data layouts in claude-db with ASCII diagrams.\n\n## Structures to Document\n\n1. **Page Layout (4096 bytes)** - internal/storage/page.go\n   - 16-byte header: PageID (u32), PageType (u8), NumSlots (u16), FreeSpaceOffset (u16), Reserved (7 bytes)\n   - 4080-byte data area\n\n2. **B-Tree Node Layout** - internal/storage/btree.go\n   - Header: IsLeaf (u8), NumKeys (u16), NumChildren (u16)\n   - Keys: length-prefixed variable data\n   - Values (leaf): uint64 location encodings\n   - Children (internal): uint32 PageIDs\n\n3. **Table Row Layout** - internal/table/table.go\n   - Length prefix (u16)\n   - Row header: RowID (u64), NumValues (u16)\n   - Values: type-tagged (u8 type, u8 null flag, variable data)\n\n4. **Database Catalog (Page 0)** - internal/catalog/catalog.go\n   - Magic (0xCDB0), NumTables (u16)\n   - TableInfo: name, RootPage, NextRowID, PrimaryKey, columns\n   - ColumnInfo: name, type, flags (PrimaryKey/NotNull bits)\n\n5. **Row Location Encoding** - internal/table/table.go:290-291\n   - uint64: upper 32 bits = PageID, lower 32 bits = offset\n\n## Deliverables\n- docs/binary-format.md with ASCII tables for each layout\n- Byte offset annotations\n- Hex dump examples\n- Size constraints and limits\n- All little-endian, constants reference table","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-04T08:50:53.530093-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:05:19.912507-07:00","closed_at":"2026-01-04T09:41:45.926944-07:00","close_reason":"Closed"}
{"id":"cdb-ce9","title":"Merge: slit-mk4f1pp1","description":"branch: polecat/slit-mk4f1pp1\ntarget: main\nsource_issue: slit-mk4f1pp1\nrig: claudedb\nagent_bead: claude-db-claudedb-polecat-slit\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T12:44:38.774721-07:00","created_by":"claudedb/polecats/slit","updated_at":"2026-01-07T16:09:17.948156-07:00","closed_at":"2026-01-07T16:09:17.948156-07:00","close_reason":"Already merged to main"}
{"id":"cdb-claudedb-polecat-capable","title":"cdb-claudedb-polecat-capable","description":"cdb-claudedb-polecat-capable\n\nrole_type: polecat\nrig: claudedb\nagent_state: spawning\nhook_bead: cdb-loe\nrole_bead: hq-polecat-role\ncleanup_status: has_uncommitted\nactive_mr: cdb-4kh\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T14:18:58.919684-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:28.386703-07:00"}
{"id":"cdb-claudedb-polecat-cheedo","title":"Agent: cdb-claudedb-polecat-cheedo","description":"Agent: cdb-claudedb-polecat-cheedo\n\nrole_type: \nrig: null\nagent_state: \nhook_bead: null\nrole_bead: null\ncleanup_status: null\nactive_mr: cdb-0he\nnotification_level: null","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T15:48:03.451216-07:00","created_by":"claudedb/polecats/cheedo","updated_at":"2026-01-07T17:29:45.715867-07:00","labels":["gt:agent","rig:claudedb","role_type:polecat"]}
{"id":"cdb-claudedb-polecat-dag","title":"cdb-claudedb-polecat-dag","description":"cdb-claudedb-polecat-dag\n\nrole_type: polecat\nrig: claudedb\nagent_state: spawning\nhook_bead: cdb-lyg\nrole_bead: hq-polecat-role\ncleanup_status: has_uncommitted\nactive_mr: cdb-21x\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T14:21:02.526192-07:00","created_by":"mayor","updated_at":"2026-01-07T17:33:34.631042-07:00"}
{"id":"cdb-claudedb-polecat-dementus","title":"cdb-claudedb-polecat-dementus","description":"cdb-claudedb-polecat-dementus\n\nrole_type: polecat\nrig: claudedb\nagent_state: spawning\nhook_bead: cdb-8p0\nrole_bead: hq-polecat-role\ncleanup_status: null\nactive_mr: cdb-9ym\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T14:05:57.764374-07:00","created_by":"mayor","updated_at":"2026-01-07T17:33:25.465635-07:00"}
{"id":"cdb-claudedb-polecat-furiosa","title":"cdb-claudedb-polecat-furiosa","description":"cdb-claudedb-polecat-furiosa\n\nrole_type: polecat\nrig: claudedb\nagent_state: running\nhook_bead: null\nrole_bead: hq-polecat-role\ncleanup_status: null\nactive_mr: cdb-3yt\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T16:20:21.947202-07:00","created_by":"claudedb/polecats/furiosa","updated_at":"2026-01-07T16:31:35.432207-07:00"}
{"id":"cdb-claudedb-polecat-nux","title":"cdb-claudedb-polecat-nux","description":"cdb-claudedb-polecat-nux\n\nrole_type: polecat\nrig: claudedb\nagent_state: running\nhook_bead: null\nrole_bead: hq-polecat-role\ncleanup_status: null\nactive_mr: cdb-7dc\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T16:23:04.872044-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:32:00.252708-07:00"}
{"id":"cdb-claudedb-polecat-rictus","title":"Agent: cdb-claudedb-polecat-rictus","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T17:32:13.232907-07:00","created_by":"claudedb/polecats/rictus","updated_at":"2026-01-07T17:32:13.238325-07:00","labels":["gt:agent","rig:claudedb","role_type:polecat"]}
{"id":"cdb-claudedb-polecat-toast","title":"cdb-claudedb-polecat-toast","description":"cdb-claudedb-polecat-toast\n\nrole_type: polecat\nrig: claudedb\nagent_state: spawning\nhook_bead: cdb-lyg\nrole_bead: hq-polecat-role\ncleanup_status: has_uncommitted\nactive_mr: cdb-acl\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T14:20:33.075553-07:00","created_by":"mayor","updated_at":"2026-01-07T17:33:17.863008-07:00"}
{"id":"cdb-claudedb-polecat-valkyrie","title":"cdb-claudedb-polecat-valkyrie","description":"cdb-claudedb-polecat-valkyrie\n\nrole_type: polecat\nrig: claudedb\nagent_state: spawning\nhook_bead: cdb-f7o\nrole_bead: hq-polecat-role\ncleanup_status: null\nactive_mr: cdb-xia\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T15:58:21.950394-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:23.692057-07:00"}
{"id":"cdb-cti","title":"Merge: nux-btree","description":"branch: polecat/nux-btree-range\ntarget: main\nsource_issue: nux-btree\nrig: claudedb\nagent_bead: claude-db-claudedb-polecat-nux\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T13:38:31.279646-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T16:09:17.944119-07:00","closed_at":"2026-01-07T16:09:17.944119-07:00","close_reason":"Already merged to main"}
{"id":"cdb-d5t","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:42:24.038755-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T15:42:24.038755-07:00"}
{"id":"cdb-dag","title":"cdb-dag","description":"cdb-dag\n\nrole_type: polecat\nrig: claudedb\nagent_state: spawning\nhook_bead: cdb-lyg\nrole_bead: hq-polecat-role\ncleanup_status: has_uncommitted\nactive_mr: cdb-3gh\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-07T14:21:02.526192-07:00","created_by":"mayor","updated_at":"2026-01-07T17:31:13.312983-07:00"}
{"id":"cdb-doj","title":"Query Engine Performance Improvements","description":"Currently all queries use full table scans. The B+ tree index infrastructure exists but is never consulted during SELECT execution. This epic tracks work to build a proper query planner and leverage existing index infrastructure.\n\n## Current State\n- executor.go:299 always calls tbl.Scan() regardless of WHERE clause\n- B+ tree indexes are populated on INSERT but never used for lookups\n- ScanWithFilter() method exists but is unused\n- No query planner - queries go straight to executor\n\n## Goals\n- Use existing PK index for equality lookups\n- Build query planner to choose access paths\n- Support secondary indexes\n- Range scan support\n- ORDER BY + LIMIT optimization\n- Bounded buffer pool with LRU eviction\n\n## Key Files\n- internal/sql/executor/executor.go\n- internal/storage/btree.go\n- internal/table/table.go\n- internal/storage/pager.go","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-07T12:18:19.205962-07:00","created_by":"mayor","updated_at":"2026-01-07T16:32:42.037198-07:00","closed_at":"2026-01-07T16:32:42.037198-07:00","close_reason":"All dependencies complete: PK lookups, ScanWithFilter, range scans, ORDER BY+LIMIT, LRU buffer pool, table statistics, secondary indexes","dependencies":[{"issue_id":"cdb-doj","depends_on_id":"cdb-lyg","type":"blocks","created_at":"2026-01-07T12:19:53.805623-07:00","created_by":"mayor"},{"issue_id":"cdb-doj","depends_on_id":"cdb-70r","type":"blocks","created_at":"2026-01-07T12:19:53.926971-07:00","created_by":"mayor"},{"issue_id":"cdb-doj","depends_on_id":"cdb-xa7","type":"blocks","created_at":"2026-01-07T12:19:53.95799-07:00","created_by":"mayor"},{"issue_id":"cdb-doj","depends_on_id":"cdb-8p0","type":"blocks","created_at":"2026-01-07T12:21:47.533211-07:00","created_by":"mayor"},{"issue_id":"cdb-doj","depends_on_id":"cdb-xsr","type":"blocks","created_at":"2026-01-07T12:21:47.563981-07:00","created_by":"mayor"},{"issue_id":"cdb-doj","depends_on_id":"cdb-loe","type":"blocks","created_at":"2026-01-07T12:21:47.599377-07:00","created_by":"mayor"}]}
{"id":"cdb-e33","title":"SQL Query Interface","description":"Web form to execute SQL queries and display results as HTML tables. Core user interaction for the database.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-07T16:52:48.193316-07:00","created_by":"mayor","updated_at":"2026-01-07T16:52:48.193316-07:00","dependencies":[{"issue_id":"cdb-e33","depends_on_id":"cdb-28k","type":"blocks","created_at":"2026-01-07T16:56:02.095725-07:00","created_by":"mayor"},{"issue_id":"cdb-e33","depends_on_id":"cdb-5xp","type":"blocks","created_at":"2026-01-07T16:56:25.919045-07:00","created_by":"mayor"},{"issue_id":"cdb-e33","depends_on_id":"cdb-5us","type":"blocks","created_at":"2026-01-07T16:56:25.959693-07:00","created_by":"mayor"},{"issue_id":"cdb-e33","depends_on_id":"cdb-3f4","type":"blocks","created_at":"2026-01-07T16:56:25.999476-07:00","created_by":"mayor"},{"issue_id":"cdb-e33","depends_on_id":"cdb-1tn","type":"blocks","created_at":"2026-01-07T16:56:26.038756-07:00","created_by":"mayor"}]}
{"id":"cdb-ef7","title":"Session ended: gt-claudedb-nux","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:31:08.254178-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T16:31:08.254178-07:00"}
{"id":"cdb-epo","title":"Use PK index for equality lookups","description":"Modify executeSelect() to detect simple primary key equality in WHERE clause and use btree.Search() instead of tbl.Scan().\n\n## Current Behavior\n- Line 299: `rows, err := tbl.Scan()` always does full scan\n- Even `WHERE id = 5` scans entire table\n\n## Implementation\n1. Before calling Scan(), analyze WHERE clause\n2. Detect pattern: BinaryExpression with OpEquals on PK column\n3. If detected, call btree.Search(key) instead\n4. Reduces complexity from O(n) to O(log n)\n\n## Files\n- internal/sql/executor/executor.go (line ~280-299)\n\n## Acceptance Criteria\n- SELECT with PK equality uses index lookup\n- Benchmark shows page access reduction (e.g., 4 pages vs 250 for 1M rows)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T12:19:05.162456-07:00","created_by":"mayor","updated_at":"2026-01-07T14:05:19.906253-07:00","closed_at":"2026-01-07T12:21:32.610379-07:00","close_reason":"Superseded by existing claude-db-8p0 (Use B-tree for primary key equality lookups) which has detailed edge cases, tests, and proper dependencies"}
{"id":"cdb-f6o","title":"Session ended: gt-claudedb-toast","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:30:29.333645-07:00","created_by":"claudedb/polecats/toast","updated_at":"2026-01-07T17:30:29.333645-07:00"}
{"id":"cdb-f7o","title":"Add EXPLAIN command to show query plans","description":"dispatched_by: mayor\n\n## Problem\nUsers have no visibility into how queries are executed.\n\n## Solution\nAdd EXPLAIN statement that shows the query plan without executing.\n\n## Syntax\n```sql\nEXPLAIN SELECT * FROM users WHERE id = 5;\nEXPLAIN SELECT * FROM users WHERE name = 'Alice' AND age \u003e 30;\n```\n\n## Output Format\n```\nPlan Type: IndexScan\nTable: users\nIndex: PRIMARY\nIndex Condition: id = 5\nEstimated Rows: 1\nEstimated Cost: 1.0\n\n---\n\nPlan Type: TableScan\nTable: users  \nFilter: name = 'Alice' AND age \u003e 30\nEstimated Rows: 100\nEstimated Cost: 1000.0\n```\n\n## Implementation\n\n```go\n// AST\ntype ExplainStatement struct {\n    Statement Statement\n}\n\n// Parser addition\nfunc (p *Parser) parseExplain() (*ExplainStatement, error) {\n    p.expect(TokenExplain)\n    \n    // Parse the inner statement\n    innerStmt, err := p.parseStatement()\n    if err != nil {\n        return nil, err\n    }\n    \n    return \u0026ExplainStatement{Statement: innerStmt}, nil\n}\n\n// Executor\nfunc (e *Executor) executeExplain(stmt *ExplainStatement) (*Result, error) {\n    plan, err := e.planner.Plan(stmt.Statement)\n    if err != nil {\n        return nil, err\n    }\n    \n    return \u0026Result{\n        Message: plan.Explain(),\n    }, nil\n}\n\n// QueryPlan.Explain()\nfunc (p *QueryPlan) Explain() string {\n    var sb strings.Builder\n    \n    sb.WriteString(fmt.Sprintf(\"Plan Type: %s\\n\", p.Type))\n    sb.WriteString(fmt.Sprintf(\"Table: %s\\n\", p.Table))\n    \n    if p.Index != nil {\n        sb.WriteString(fmt.Sprintf(\"Index: %s\\n\", p.Index.Name))\n    }\n    \n    if len(p.IndexPredicates) \u003e 0 {\n        sb.WriteString(\"Index Condition: \")\n        sb.WriteString(formatPredicates(p.IndexPredicates))\n        sb.WriteString(\"\\n\")\n    }\n    \n    if len(p.ResidualPredicates) \u003e 0 {\n        sb.WriteString(\"Filter: \")\n        sb.WriteString(formatPredicates(p.ResidualPredicates))\n        sb.WriteString(\"\\n\")\n    }\n    \n    sb.WriteString(fmt.Sprintf(\"Estimated Rows: %.0f\\n\", p.EstimatedRows))\n    sb.WriteString(fmt.Sprintf(\"Estimated Cost: %.1f\\n\", p.EstimatedCost))\n    \n    return sb.String()\n}\n```\n\n## Files to Modify\n- internal/sql/lexer/lexer.go (TokenExplain)\n- internal/sql/parser/ast.go (ExplainStatement)\n- internal/sql/parser/parser.go (parseExplain)\n- internal/sql/executor/executor.go (executeExplain)\n- internal/sql/planner/planner.go (Explain method)\n\n## Edge Cases\n\n| Case | Input | Expected Output |\n|------|-------|-----------------|\n| Explain SELECT | `EXPLAIN SELECT * FROM t` | Shows plan for SELECT |\n| Explain UPDATE | `EXPLAIN UPDATE t SET x=1` | Shows plan for UPDATE |\n| Explain DELETE | `EXPLAIN DELETE FROM t` | Shows plan for DELETE |\n| Table not found | `EXPLAIN SELECT * FROM nosuchtable` | Error: \"table nosuchtable does not exist\" |\n| Syntax error in inner | `EXPLAIN SELEC * FROM t` | Parse error on inner statement |\n| EXPLAIN EXPLAIN | `EXPLAIN EXPLAIN SELECT...` | Error or shows plan for EXPLAIN |\n| EXPLAIN INSERT | `EXPLAIN INSERT INTO t...` | Plan or \"not supported\" (INSERT doesn't scan) |\n\n## Test Scenarios\n\n```go\nfunc TestExplainSelect(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT\")\n    \n    result, err := exec.Execute(parseSQL(\"EXPLAIN SELECT * FROM users WHERE id = 5\"))\n    require.NoError(t, err)\n    \n    output := result.Message\n    assert.Contains(t, output, \"Plan Type: IndexScan\")\n    assert.Contains(t, output, \"Table: users\")\n    assert.Contains(t, output, \"Index: PRIMARY\")\n    assert.Contains(t, output, \"Index Condition: id = 5\")\n    assert.Contains(t, output, \"Estimated Rows:\")\n}\n\nfunc TestExplainTableScan(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT\")\n    \n    result, err := exec.Execute(parseSQL(\n        \"EXPLAIN SELECT * FROM users WHERE name = 'Alice'\"))\n    require.NoError(t, err)\n    \n    output := result.Message\n    assert.Contains(t, output, \"Plan Type: TableScan\")\n    assert.Contains(t, output, \"Filter: name = 'Alice'\")\n    assert.NotContains(t, output, \"Index:\") // No index used\n}\n\nfunc TestExplainNonExistentTable(t *testing.T) {\n    exec := setupExecutor(t)\n    \n    _, err := exec.Execute(parseSQL(\"EXPLAIN SELECT * FROM nosuchtable\"))\n    assert.ErrorContains(t, err, \"does not exist\")\n}\n\nfunc TestExplainDoesNotExecute(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \"id INTEGER PRIMARY KEY\")\n    \n    // Insert a row\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1)\"))\n    \n    // EXPLAIN DELETE should NOT actually delete\n    _, err := exec.Execute(parseSQL(\"EXPLAIN DELETE FROM users WHERE id = 1\"))\n    require.NoError(t, err)\n    \n    // Row should still exist\n    result, _ := exec.Execute(parseSQL(\"SELECT * FROM users\"))\n    assert.Equal(t, 1, len(result.Rows))\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. EXPLAIN token defined\ngrep -n \"TokenExplain\\|EXPLAIN\" internal/sql/lexer/lexer.go\n# Expected: Shows token definition\n\n# 2. ExplainStatement in AST\ngrep -n \"type ExplainStatement struct\" internal/sql/parser/ast.go\n# Expected: Shows struct definition\n\n# 3. parseExplain function exists\ngrep -n \"func.*parseExplain\" internal/sql/parser/parser.go\n# Expected: Shows parser function\n\n# 4. Explain method on QueryPlan\ngrep -n \"func.*QueryPlan.*Explain\" internal/sql/planner/planner.go\n# Expected: Shows Explain method\n\n# 5. Tests pass\ngo test ./... -v -run \"TestExplain\"\n# Expected: All PASS\n```\n\n## Output Format Specification (exact format for verification)\n\n```\nPlan Type: \u003cIndexScan|IndexRangeScan|TableScan\u003e\nTable: \u003ctable_name\u003e\n[Index: \u003cindex_name\u003e]\n[Index Condition: \u003cpredicate\u003e[ AND \u003cpredicate\u003e...]]\n[Filter: \u003cpredicate\u003e[ AND \u003cpredicate\u003e...]]\nEstimated Rows: \u003cnumber\u003e\nEstimated Cost: \u003cnumber\u003e\n```\n\nLines in brackets are optional (only shown when applicable).\n\n## Definition of Done\n- [ ] `EXPLAIN` keyword lexes as `TokenExplain`\n- [ ] `ExplainStatement` struct wraps inner statement\n- [ ] `parseExplain()` correctly parses `EXPLAIN SELECT/UPDATE/DELETE`\n- [ ] `executeExplain()` calls planner but does NOT execute the inner query\n- [ ] `QueryPlan.Explain()` returns formatted string matching specification\n- [ ] Output contains: Plan Type, Table, (Index), (Index Condition), (Filter), Estimated Rows, Cost\n- [ ] `TestExplainSelect` passes: shows IndexScan for PK query\n- [ ] `TestExplainTableScan` passes: shows TableScan for non-indexed query\n- [ ] `TestExplainDoesNotExecute` passes: EXPLAIN DELETE doesn't delete rows","status":"closed","priority":3,"issue_type":"feature","assignee":"claudedb/polecats/valkyrie","created_at":"2026-01-05T05:49:04.854487-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T16:04:40.832801-07:00","closed_at":"2026-01-07T16:04:40.832801-07:00","close_reason":"Implemented EXPLAIN command with TokenExplain, ExplainStatement, parseExplain, and executor support. All tests pass.","dependencies":[{"issue_id":"cdb-f7o","depends_on_id":"cdb-goh","type":"blocks","created_at":"2026-01-05T05:51:31.599261-07:00","created_by":"cabewaldrop"}]}
{"id":"cdb-fcu","title":"Merge: furiosa-mk4ewicq","description":"branch: polecat/furiosa-mk4ewicq\ntarget: main\nsource_issue: furiosa-mk4ewicq\nrig: claudedb\nagent_bead: claude-db-claudedb-polecat-furiosa\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T12:42:52.002358-07:00","created_by":"claudedb/polecats/furiosa","updated_at":"2026-01-07T16:09:17.950518-07:00","closed_at":"2026-01-07T16:09:17.950518-07:00","close_reason":"Already merged to main"}
{"id":"cdb-g1w","title":"Query Plan Visualization","description":"Display EXPLAIN query plans in a readable format.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T16:52:49.127552-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:38.357849-07:00","closed_at":"2026-01-07T17:32:38.357849-07:00","close_reason":"All child tasks complete: EXPLAIN integration and query plan formatting","dependencies":[{"issue_id":"cdb-g1w","depends_on_id":"cdb-e33","type":"blocks","created_at":"2026-01-07T16:56:02.189513-07:00","created_by":"mayor"},{"issue_id":"cdb-g1w","depends_on_id":"cdb-kdh","type":"blocks","created_at":"2026-01-07T16:56:34.95708-07:00","created_by":"mayor"},{"issue_id":"cdb-g1w","depends_on_id":"cdb-034","type":"blocks","created_at":"2026-01-07T16:56:34.993515-07:00","created_by":"mayor"}]}
{"id":"cdb-gj1","title":"Table data preview","description":"## Problem\nUsers want to quickly see data in a table without writing SQL.\n\n## Solution\nGET /tables/{name}/data with paginated data preview.\n\n## Implementation\n\n```html\n{{/* templates/table_data.html */}}\n{{define \"title\"}}{{.Table}} Data - claudedb{{end}}\n\n{{define \"content\"}}\n\u003cdiv class=\"table-data-page\"\u003e\n    \u003cnav class=\"breadcrumb\"\u003e\n        \u003ca href=\"/tables\"\u003eTables\u003c/a\u003e / \n        \u003ca href=\"/tables/{{.Table}}\"\u003e{{.Table}}\u003c/a\u003e / \n        \u003cspan\u003eData\u003c/span\u003e\n    \u003c/nav\u003e\n    \n    \u003ch1\u003e{{.Table}} Data\u003c/h1\u003e\n    \n    \u003cdiv class=\"data-meta\"\u003e\n        \u003cspan\u003eShowing {{.Offset}}-{{.EndOffset}} of {{.TotalRows}} rows\u003c/span\u003e\n    \u003c/div\u003e\n    \n    {{if .Rows}}\n    \u003cdiv class=\"table-wrapper\"\u003e\n        \u003ctable class=\"data-table\"\u003e\n            \u003cthead\u003e\n                \u003ctr\u003e\n                    {{range .Columns}}\n                    \u003cth\u003e{{.Name}}\u003c/th\u003e\n                    {{end}}\n                    \u003cth class=\"actions-col\"\u003eActions\u003c/th\u003e\n                \u003c/tr\u003e\n            \u003c/thead\u003e\n            \u003ctbody\u003e\n                {{range .Rows}}\n                \u003ctr data-pk=\"{{.PrimaryKey}}\"\u003e\n                    {{range .Values}}\n                    \u003ctd\u003e{{renderValue .}}\u003c/td\u003e\n                    {{end}}\n                    \u003ctd class=\"actions-col\"\u003e\n                        \u003cbutton hx-get=\"/tables/{{$.Table}}/edit/{{.PrimaryKey}}\"\n                                hx-target=\"#edit-modal\"\n                                class=\"btn-small\"\u003eEdit\u003c/button\u003e\n                        \u003cbutton hx-delete=\"/tables/{{$.Table}}/{{.PrimaryKey}}\"\n                                hx-confirm=\"Delete this row?\"\n                                hx-target=\"closest tr\"\n                                hx-swap=\"outerHTML\"\n                                class=\"btn-small btn-danger\"\u003eDelete\u003c/button\u003e\n                    \u003c/td\u003e\n                \u003c/tr\u003e\n                {{end}}\n            \u003c/tbody\u003e\n        \u003c/table\u003e\n    \u003c/div\u003e\n    \n    \u003cdiv class=\"pagination\"\u003e\n        {{if gt .Offset 0}}\n        \u003ca href=\"?offset={{.PrevOffset}}\u0026limit={{.Limit}}\" \n           hx-get=\"/tables/{{.Table}}/data?offset={{.PrevOffset}}\u0026limit={{.Limit}}\"\n           hx-target=\"#data-container\"\n           class=\"btn\"\u003ePrevious\u003c/a\u003e\n        {{end}}\n        {{if .HasMore}}\n        \u003ca href=\"?offset={{.NextOffset}}\u0026limit={{.Limit}}\"\n           hx-get=\"/tables/{{.Table}}/data?offset={{.NextOffset}}\u0026limit={{.Limit}}\"\n           hx-target=\"#data-container\"\n           class=\"btn\"\u003eNext\u003c/a\u003e\n        {{end}}\n    \u003c/div\u003e\n    {{else}}\n    \u003cp class=\"no-data\"\u003eNo data in this table. \u003ca href=\"/tables/{{.Table}}/insert\"\u003eInsert a row?\u003c/a\u003e\u003c/p\u003e\n    {{end}}\n    \n    \u003cdiv id=\"edit-modal\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n{{end}}\n```\n\n```go\nfunc (s *Server) handleTableData(w http.ResponseWriter, r *http.Request) {\n    tableName := chi.URLParam(r, \"name\")\n    exec := GetExecutor(r)\n    \n    // Parse pagination params\n    limit := 50\n    if l := r.URL.Query().Get(\"limit\"); l != \"\" {\n        limit, _ = strconv.Atoi(l)\n        if limit \u003c 1 || limit \u003e 1000 {\n            limit = 50\n        }\n    }\n    offset := 0\n    if o := r.URL.Query().Get(\"offset\"); o != \"\" {\n        offset, _ = strconv.Atoi(o)\n        if offset \u003c 0 {\n            offset = 0\n        }\n    }\n    \n    // Get total count\n    countResult, _ := exec.Execute(fmt.Sprintf(\"SELECT COUNT(*) FROM %s\", tableName))\n    totalRows := 0\n    if len(countResult.Rows) \u003e 0 {\n        totalRows, _ = countResult.Rows[0][0].(int)\n    }\n    \n    // Get page of data\n    query := fmt.Sprintf(\"SELECT * FROM %s LIMIT %d OFFSET %d\", tableName, limit, offset)\n    result, err := exec.Execute(query)\n    if err != nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\"Error\": err.Error()})\n        return\n    }\n    \n    // ... render template with pagination data\n}\n```\n\n## Files to Create/Modify\n- internal/web/templates/table_data.html\n- internal/web/handlers.go (handleTableData)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Empty table | Show \"No data\" with insert link |\n| Table without primary key | Disable edit/delete (no way to identify row) |\n| 10000+ rows | Pagination required, dont load all |\n| Invalid offset (\u003etotal) | Show empty page or redirect to page 1 |\n| Negative offset | Treat as 0 |\n| Limit \u003e 1000 | Cap at 1000 |\n| HTMX partial request | Return just tbody, not full page |\n\n## Test Scenarios\n\n```go\nfunc TestTableDataPagination(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE nums (n INTEGER PRIMARY KEY)\")\n    for i := 1; i \u003c= 100; i++ {\n        exec.Execute(fmt.Sprintf(\"INSERT INTO nums VALUES (%d)\", i))\n    }\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    // First page\n    resp, err := http.Get(ts.URL + \"/tables/nums/data?limit=10\")\n    require.NoError(t, err)\n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"1-10 of 100\")\n    assert.Contains(t, html, \"Next\")\n    assert.NotContains(t, html, \"Previous\")\n    \n    // Middle page\n    resp, err = http.Get(ts.URL + \"/tables/nums/data?limit=10\u0026offset=50\")\n    require.NoError(t, err)\n    body, _ = io.ReadAll(resp.Body)\n    html = string(body)\n    assert.Contains(t, html, \"Previous\")\n    assert.Contains(t, html, \"Next\")\n}\n\nfunc TestTableDataEmpty(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE empty (id INTEGER PRIMARY KEY)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/empty/data\")\n    require.NoError(t, err)\n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"No data\")\n    assert.Contains(t, string(body), \"Insert\")\n}\n```\n\n## Definition of Done\n- [ ] GET /tables/{name}/data route registered\n- [ ] Displays rows in table format\n- [ ] Pagination with limit/offset (default 50)\n- [ ] Previous/Next navigation\n- [ ] Row count display\n- [ ] Edit button per row (links to edit form)\n- [ ] Delete button per row with confirmation\n- [ ] Empty state with insert link\n- [ ] HTMX support for partial page updates\n- [ ] TestTableDataPagination passes\n- [ ] TestTableDataEmpty passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"capable","created_at":"2026-01-07T16:55:27.696326-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:02.03297-07:00","closed_at":"2026-01-07T17:32:02.03297-07:00","close_reason":"Implemented table data preview with pagination"}
{"id":"cdb-gnr","title":"Support secondary indexes (CREATE INDEX)","description":"Add CREATE INDEX syntax and secondary B-tree indexes for non-PK columns","status":"in_progress","priority":2,"issue_type":"feature","created_at":"2026-01-07T16:21:07.675951-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T16:21:20.46253-07:00"}
{"id":"cdb-goh","title":"Add query planner to analyze WHERE clauses","description":"## Problem\nThere is no query planner - the executor directly executes queries without analyzing optimization opportunities.\n\n## Solution\nCreate a query planner that analyzes WHERE clauses and produces execution plans.\n\n## Design\n\n```go\ntype PlanType int\nconst (\n    PlanTableScan PlanType = iota\n    PlanIndexScan      // Exact key lookup via B-tree Search\n    PlanIndexRangeScan // Range scan via B-tree iterator\n)\n\ntype QueryPlan struct {\n    Type               PlanType\n    Table              string\n    Index              *IndexInfo          // nil for TableScan\n    IndexPredicates    []Predicate         // Pushed to index\n    ResidualPredicates []Predicate         // Applied post-fetch\n    Projection         []int               // Column indices (nil = all)\n    Limit              *int\n    EstimatedRows      float64\n    EstimatedCost      float64\n}\n\ntype Predicate struct {\n    Column   string\n    Operator CompareOp  // Eq, Lt, Gt, Le, Ge, Ne\n    Value    interface{}\n}\n\ntype Planner struct {\n    catalog *catalog.Catalog\n}\n\nfunc (p *Planner) Plan(stmt parser.Statement) (*QueryPlan, error)\nfunc (plan *QueryPlan) Explain() string\n```\n\n## Predicate Classification\n\n**Index-usable (SARGable)**:\n- `column = literal`  IndexScan\n- `column \u003e literal`, `column \u003c literal`, `column \u003e= literal`, `column \u003c= literal`  IndexRangeScan\n- `column BETWEEN a AND b`  IndexRangeScan\n\n**NOT index-usable (residual)**:\n- `column != literal` (requires full scan to find non-matches)\n- `column + 1 = 5` (expression on column)\n- `func(column) = value` (function on column)  \n- `column1 = column2` (no literal)\n- `column LIKE '%foo'` (leading wildcard)\n\n## Files to Create/Modify\n- internal/sql/planner/planner.go (new)\n- internal/sql/planner/predicate.go (new)\n- internal/sql/executor/executor.go\n\n## Edge Cases\n\n| Case | Query | Expected Plan |\n|------|-------|---------------|\n| No WHERE | `SELECT * FROM t` | TableScan, no predicates |\n| PK equality | `SELECT * FROM t WHERE id = 5` | IndexScan on PRIMARY |\n| PK range | `SELECT * FROM t WHERE id \u003e 10` | IndexRangeScan on PRIMARY |\n| Non-indexed column | `SELECT * FROM t WHERE name = 'x'` | TableScan, residual: [name='x'] |\n| AND with PK | `SELECT * FROM t WHERE id = 5 AND name = 'x'` | IndexScan on PRIMARY, residual: [name='x'] |\n| OR condition | `SELECT * FROM t WHERE id = 1 OR id = 2` | TableScan (OR not optimized in v1) |\n| NOT condition | `SELECT * FROM t WHERE NOT id = 5` | TableScan, residual: [NOT id=5] |\n| Expression on column | `SELECT * FROM t WHERE id + 1 = 5` | TableScan, residual: [id+1=5] |\n| NULL check | `SELECT * FROM t WHERE id IS NULL` | TableScan (B-tree doesn't index NULLs) |\n| Empty table | `SELECT * FROM empty_t WHERE id = 1` | IndexScan, EstimatedRows: 0 |\n| Non-existent table | `SELECT * FROM nosuchtable` | Error: \"table nosuchtable does not exist\" |\n\n## Test Scenarios\n\n```go\nfunc TestPlannerSelectPK(t *testing.T) {\n    // Setup: Table 'users' with PK on 'id'\n    planner := setupPlannerWithTable(t, \"users\", []Column{\n        {Name: \"id\", Type: TypeInteger, PrimaryKey: true},\n        {Name: \"name\", Type: TypeText},\n    })\n    \n    stmt := parseSelect(\"SELECT * FROM users WHERE id = 42\")\n    plan, err := planner.Plan(stmt)\n    \n    require.NoError(t, err)\n    assert.Equal(t, PlanIndexScan, plan.Type)\n    assert.Equal(t, \"users\", plan.Table)\n    assert.Equal(t, \"PRIMARY\", plan.Index.Name)\n    assert.Len(t, plan.IndexPredicates, 1)\n    assert.Equal(t, \"id\", plan.IndexPredicates[0].Column)\n    assert.Equal(t, OpEq, plan.IndexPredicates[0].Operator)\n    assert.Equal(t, int64(42), plan.IndexPredicates[0].Value)\n    assert.Empty(t, plan.ResidualPredicates)\n}\n\nfunc TestPlannerMixedPredicates(t *testing.T) {\n    stmt := parseSelect(\"SELECT * FROM users WHERE id = 42 AND name = 'Alice'\")\n    plan, err := planner.Plan(stmt)\n    \n    require.NoError(t, err)\n    assert.Equal(t, PlanIndexScan, plan.Type)\n    assert.Len(t, plan.IndexPredicates, 1)      // id = 42\n    assert.Len(t, plan.ResidualPredicates, 1)   // name = 'Alice'\n}\n\nfunc TestPlannerExplain(t *testing.T) {\n    stmt := parseSelect(\"SELECT * FROM users WHERE id = 42 AND name = 'Alice'\")\n    plan, _ := planner.Plan(stmt)\n    \n    explain := plan.Explain()\n    assert.Contains(t, explain, \"IndexScan\")\n    assert.Contains(t, explain, \"PRIMARY\")\n    assert.Contains(t, explain, \"Index Cond: id = 42\")\n    assert.Contains(t, explain, \"Filter: name = 'Alice'\")\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Package exists and compiles\ngo build ./internal/sql/planner/...\n# Expected: exit code 0\n\n# 2. Planner struct and Plan method exist\ngrep -n \"func (p \\*Planner) Plan\" internal/sql/planner/planner.go\n# Expected: Returns line number\n\n# 3. All tests pass\ngo test ./internal/sql/planner/... -v\n# Expected: PASS for all tests\n\n# 4. Executor uses planner\ngrep -n \"planner.Plan\" internal/sql/executor/executor.go\n# Expected: Returns line number(s) showing planner is called\n```\n\n## Definition of Done\n- [ ] `internal/sql/planner/` package exists with `planner.go` and `predicate.go`\n- [ ] `Planner.Plan()` returns correct `PlanType` for all 10 edge cases in table\n- [ ] `Explain()` output includes: plan type, index name, index conditions, filter conditions\n- [ ] Executor's `executeSelect` calls `planner.Plan()` before choosing access method\n- [ ] `go test ./internal/sql/planner/... -v` passes\n- [ ] At least 5 test cases covering: TableScan, IndexScan, mixed predicates, error cases","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-05T05:39:23.697454-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:05:19.912145-07:00","closed_at":"2026-01-07T13:17:11.677968-07:00","close_reason":"Implemented by nux in commit b70a1d9: Add query planner to analyze WHERE clauses"}
{"id":"cdb-huu","title":"Show table schema","description":"## Problem\nUsers need to see table structure (columns, types, constraints).\n\n## Solution\nGET /tables/{name} showing schema and indexes.\n\n## Implementation\n\n```html\n{{/* templates/table.html */}}\n{{define \"title\"}}{{.Table.Name}} - claudedb{{end}}\n\n{{define \"content\"}}\n\u003cdiv class=\"table-detail\"\u003e\n    \u003cnav class=\"breadcrumb\"\u003e\n        \u003ca href=\"/tables\"\u003eTables\u003c/a\u003e / \u003cspan\u003e{{.Table.Name}}\u003c/span\u003e\n    \u003c/nav\u003e\n    \n    \u003ch1\u003e{{.Table.Name}}\u003c/h1\u003e\n    \n    \u003csection class=\"schema-section\"\u003e\n        \u003ch2\u003eSchema\u003c/h2\u003e\n        \u003ctable class=\"schema-table\"\u003e\n            \u003cthead\u003e\n                \u003ctr\u003e\n                    \u003cth\u003eColumn\u003c/th\u003e\n                    \u003cth\u003eType\u003c/th\u003e\n                    \u003cth\u003eConstraints\u003c/th\u003e\n                \u003c/tr\u003e\n            \u003c/thead\u003e\n            \u003ctbody\u003e\n                {{range .Table.Columns}}\n                \u003ctr\u003e\n                    \u003ctd\u003e{{.Name}}\u003c/td\u003e\n                    \u003ctd\u003e{{.Type}}\u003c/td\u003e\n                    \u003ctd\u003e\n                        {{if .IsPrimaryKey}}\u003cspan class=\"badge pk\"\u003ePK\u003c/span\u003e{{end}}\n                        {{if .NotNull}}\u003cspan class=\"badge nn\"\u003eNOT NULL\u003c/span\u003e{{end}}\n                        {{if .Unique}}\u003cspan class=\"badge uq\"\u003eUNIQUE\u003c/span\u003e{{end}}\n                    \u003c/td\u003e\n                \u003c/tr\u003e\n                {{end}}\n            \u003c/tbody\u003e\n        \u003c/table\u003e\n    \u003c/section\u003e\n    \n    {{if .Table.Indexes}}\n    \u003csection class=\"indexes-section\"\u003e\n        \u003ch2\u003eIndexes\u003c/h2\u003e\n        \u003cul\u003e\n            {{range .Table.Indexes}}\n            \u003cli\u003e{{.Name}} on ({{.Columns}})\u003c/li\u003e\n            {{end}}\n        \u003c/ul\u003e\n    \u003c/section\u003e\n    {{end}}\n    \n    \u003csection class=\"actions\"\u003e\n        \u003ca href=\"/tables/{{.Table.Name}}/data\" class=\"btn\"\u003eView Data\u003c/a\u003e\n        \u003ca href=\"/tables/{{.Table.Name}}/insert\" class=\"btn\"\u003eInsert Row\u003c/a\u003e\n        \u003cbutton hx-delete=\"/tables/{{.Table.Name}}\" \n                hx-confirm=\"Drop table {{.Table.Name}}? This cannot be undone.\"\n                class=\"btn-danger\"\u003eDrop Table\u003c/button\u003e\n    \u003c/section\u003e\n\u003c/div\u003e\n{{end}}\n```\n\n```go\ntype ColumnInfo struct {\n    Name         string\n    Type         string\n    IsPrimaryKey bool\n    NotNull      bool\n    Unique       bool\n    Default      string\n}\n\ntype IndexInfo struct {\n    Name    string\n    Columns string\n    Unique  bool\n}\n\ntype TableDetail struct {\n    Name     string\n    Columns  []ColumnInfo\n    Indexes  []IndexInfo\n    RowCount int\n}\n\nfunc (s *Server) handleTableSchema(w http.ResponseWriter, r *http.Request) {\n    tableName := chi.URLParam(r, \"name\")\n    exec := GetExecutor(r)\n    \n    // Get schema from catalog\n    schema, err := exec.GetTableSchema(tableName)\n    if err != nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": fmt.Sprintf(\"Table not found: %s\", tableName),\n        })\n        return\n    }\n    \n    // Convert to template-friendly structs\n    detail := TableDetail{Name: tableName}\n    for _, col := range schema.Columns {\n        detail.Columns = append(detail.Columns, ColumnInfo{\n            Name:         col.Name,\n            Type:         col.Type.String(),\n            IsPrimaryKey: col.IsPrimaryKey,\n            NotNull:      col.NotNull,\n        })\n    }\n    \n    renderTemplate(w, \"table.html\", map[string]interface{}{\n        \"Table\": detail,\n    })\n}\n```\n\n## Files to Create/Modify\n- internal/web/templates/table.html\n- internal/web/handlers.go (handleTableSchema)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Table not found | Show error page with message |\n| Table with no columns | Edge case - show empty schema |\n| Table with no indexes | Hide indexes section |\n| Column with DEFAULT | Show default value |\n| Reserved word as table name | Properly handled |\n| Table name with special chars | URL-decoded correctly |\n\n## Test Scenarios\n\n```go\nfunc TestTableSchemaBasic(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/users\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    body, _ := io.ReadAll(resp.Body)\n    html := string(body)\n    assert.Contains(t, html, \"users\")\n    assert.Contains(t, html, \"id\")\n    assert.Contains(t, html, \"INTEGER\")\n    assert.Contains(t, html, \"PK\")\n    assert.Contains(t, html, \"name\")\n    assert.Contains(t, html, \"TEXT\")\n    assert.Contains(t, html, \"NOT NULL\")\n}\n\nfunc TestTableSchemaNotFound(t *testing.T) {\n    exec := setupTestExecutor(t)\n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/nonexistent\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"not found\")\n}\n\nfunc TestTableSchemaWithIndexes(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT)\")\n    exec.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/tables/users\")\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"idx_email\")\n}\n```\n\n## Definition of Done\n- [ ] GET /tables/{name} route registered\n- [ ] Shows column names, types, constraints\n- [ ] Primary key columns marked with badge\n- [ ] NOT NULL constraints shown\n- [ ] Indexes listed if present\n- [ ] Links to view data, insert row\n- [ ] Drop table button with confirmation\n- [ ] 404-style error for missing table\n- [ ] TestTableSchemaBasic passes\n- [ ] TestTableSchemaNotFound passes\n- [ ] TestTableSchemaWithIndexes passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"dag","created_at":"2026-01-07T16:55:27.496452-07:00","created_by":"mayor","updated_at":"2026-01-07T17:29:51.577649-07:00","closed_at":"2026-01-07T17:29:51.577649-07:00","close_reason":"Closed"}
{"id":"cdb-ioq","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:19:55.106581-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T14:19:55.106581-07:00"}
{"id":"cdb-j0x","title":"Merge: capable-mk4ito0g","description":"branch: polecat/capable-mk4ito0g\ntarget: main\nsource_issue: capable-mk4ito0g\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-capable\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T14:26:25.949212-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T16:09:17.940288-07:00","closed_at":"2026-01-07T16:09:17.940288-07:00","close_reason":"Already merged to main"}
{"id":"cdb-jpw","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:21:39.284728-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T14:21:39.284728-07:00"}
{"id":"cdb-jxg","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:58:49.482065-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T15:58:49.482065-07:00"}
{"id":"cdb-k3c","title":"Session ended: gt-claudedb-cheedo","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:30:02.506584-07:00","created_by":"claudedb/polecats/cheedo","updated_at":"2026-01-07T17:30:02.506584-07:00"}
{"id":"cdb-kdh","title":"EXPLAIN query integration","description":"## Problem\nUsers want to see how queries will be executed before running them.\n\n## Solution\nCheckbox to prepend EXPLAIN to queries and display plan.\n\n## Implementation\n\nThe checkbox is already in query.html (from cdb-5xp):\n```html\n\u003clabel\u003e\n    \u003cinput type=\"checkbox\" name=\"explain\" value=\"1\"\u003e\n    Show Query Plan\n\u003c/label\u003e\n```\n\nThe handler already supports it (from cdb-5us):\n```go\nif r.FormValue(\"explain\") == \"1\" {\n    sql = \"EXPLAIN \" + sql\n}\n```\n\nThis task adds proper parsing and formatting of EXPLAIN output.\n\n```go\n// internal/web/explain.go\n\ntype QueryPlan struct {\n    Type           string // TableScan, IndexScan, IndexRangeScan\n    Table          string\n    Index          string // empty for TableScan\n    EstimatedRows  int\n    Predicates     []string\n    Cost           float64\n}\n\nfunc parseExplainOutput(result *executor.Result) (*QueryPlan, error) {\n    // Parse EXPLAIN output format from claudedb\n    // Expected format: \"PlanType: IndexScan, Table: users, Index: idx_email, ...\"\n    \n    if len(result.Rows) == 0 {\n        return nil, fmt.Errorf(\"empty explain output\")\n    }\n    \n    plan := \u0026QueryPlan{}\n    \n    // Parse the explain text\n    explainText := fmt.Sprintf(\"%v\", result.Rows[0][0])\n    \n    // Extract plan details using regex or string parsing\n    if strings.Contains(explainText, \"IndexScan\") {\n        plan.Type = \"IndexScan\"\n    } else if strings.Contains(explainText, \"IndexRangeScan\") {\n        plan.Type = \"IndexRangeScan\"\n    } else {\n        plan.Type = \"TableScan\"\n    }\n    \n    // Extract table name\n    if idx := strings.Index(explainText, \"Table:\"); idx \u003e= 0 {\n        // Parse table name after \"Table:\"\n    }\n    \n    return plan, nil\n}\n```\n\n## Files to Create\n- internal/web/explain.go\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| EXPLAIN syntax error | Show SQL error (EXPLAIN doesnt fix bad SQL) |\n| EXPLAIN on INSERT/UPDATE/DELETE | Show plan for data modification |\n| EXPLAIN on multi-table JOIN | Show joined plan |\n| Unparseable EXPLAIN output | Show raw text as fallback |\n| EXPLAIN on empty table | Show plan with 0 estimated rows |\n\n## Test Scenarios\n\n```go\nfunc TestExplainCheckbox(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    exec.Execute(\"CREATE INDEX idx_name ON users(name)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    // Without explain\n    resp, _ := http.PostForm(ts.URL+\"/query\", url.Values{\n        \"sql\": {\"SELECT * FROM users WHERE name = 'Alice'\"},\n    })\n    body, _ := io.ReadAll(resp.Body)\n    assert.NotContains(t, string(body), \"IndexScan\")\n    \n    // With explain\n    resp, _ = http.PostForm(ts.URL+\"/query\", url.Values{\n        \"sql\":     {\"SELECT * FROM users WHERE name = 'Alice'\"},\n        \"explain\": {\"1\"},\n    })\n    body, _ = io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"Plan\") // Should show plan info\n}\n\nfunc TestParseExplainOutput(t *testing.T) {\n    tests := []struct {\n        name     string\n        output   string\n        wantType string\n    }{\n        {\"table scan\", \"Plan: TableScan on users\", \"TableScan\"},\n        {\"index scan\", \"Plan: IndexScan on users using idx_name\", \"IndexScan\"},\n        {\"range scan\", \"Plan: IndexRangeScan on users using pk\", \"IndexRangeScan\"},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := \u0026executor.Result{\n                Rows: [][]interface{}{{tt.output}},\n            }\n            plan, err := parseExplainOutput(result)\n            require.NoError(t, err)\n            assert.Equal(t, tt.wantType, plan.Type)\n        })\n    }\n}\n```\n\n## Definition of Done\n- [ ] Explain checkbox works in query form\n- [ ] EXPLAIN prepended to query when checked\n- [ ] Plan output displayed in results area\n- [ ] Plan type identified (TableScan, IndexScan, etc)\n- [ ] Index name shown when applicable\n- [ ] Fallback to raw text if parsing fails\n- [ ] TestExplainCheckbox passes\n- [ ] TestParseExplainOutput passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"cheedo","created_at":"2026-01-07T16:55:49.050284-07:00","created_by":"mayor","updated_at":"2026-01-07T17:29:26.930636-07:00","closed_at":"2026-01-07T17:29:26.930636-07:00","close_reason":"Closed"}
{"id":"cdb-kh1","title":"Session ended: gt-claudedb-refinery","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:30:04.938806-07:00","created_by":"claudedb/refinery","updated_at":"2026-01-07T14:30:04.938806-07:00"}
{"id":"cdb-kns","title":"Merge: furiosa-mk4ewicq","description":"branch: polecat/furiosa-mk4ewicq\ntarget: main\nsource_issue: furiosa-mk4ewicq\nrig: claudedb\nagent_bead: claude-db-claudedb-polecat-furiosa\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T13:38:52.414811-07:00","created_by":"claudedb/polecats/furiosa","updated_at":"2026-01-07T16:09:17.942292-07:00","closed_at":"2026-01-07T16:09:17.942292-07:00","close_reason":"Already merged to main"}
{"id":"cdb-loe","title":"Implement B-tree range scans","description":"## Problem\nB-tree only supports exact key lookup. Range queries like `WHERE id \u003e 10 AND id \u003c 100` still do full table scans.\n\n## Solution\nAdd iterator-based range scan with early termination support.\n\n```go\ntype ScanOptions struct {\n    StartInclusive bool\n    EndInclusive   bool\n    Limit          int   // 0 = unlimited\n    Reverse        bool  // Descending order\n}\n\ntype BTreeIterator interface {\n    Next() bool           // Advance to next key\n    Key() []byte          // Current key (valid after Next returns true)\n    Value() uint64        // Current value\n    Err() error           // Any error during iteration\n    Close()               // Release resources\n}\n\n// RangeScan returns iterator over [start, end]\n// nil start = scan from beginning, nil end = scan to end\nfunc (bt *BTree) RangeScan(start, end []byte, opts ScanOptions) BTreeIterator\n```\n\n## Implementation\n\n```go\ntype btreeIterator struct {\n    bt           *BTree\n    currentNode  *BTreeNode\n    keyIndex     int\n    endKey       []byte\n    endInclusive bool\n    limit        int\n    count        int\n    exhausted    bool\n    err          error\n}\n\nfunc (it *btreeIterator) Next() bool {\n    if it.exhausted || it.err != nil {\n        return false\n    }\n    if it.limit \u003e 0 \u0026\u0026 it.count \u003e= it.limit {\n        it.exhausted = true\n        return false\n    }\n    \n    // Advance within current node\n    it.keyIndex++\n    \n    // Move to next leaf via sibling pointer\n    if it.keyIndex \u003e= int(it.currentNode.numKeys) {\n        if it.currentNode.nextLeaf == 0 {\n            it.exhausted = true\n            return false\n        }\n        page, err := it.bt.pager.GetPage(it.currentNode.nextLeaf)\n        if err != nil {\n            it.err = err\n            return false\n        }\n        it.currentNode, it.err = deserializeNode(page)\n        if it.err != nil {\n            return false\n        }\n        it.keyIndex = 0\n    }\n    \n    // Check end bound\n    if it.endKey != nil {\n        cmp := bytes.Compare(it.currentNode.keys[it.keyIndex], it.endKey)\n        if cmp \u003e 0 || (cmp == 0 \u0026\u0026 !it.endInclusive) {\n            it.exhausted = true\n            return false\n        }\n    }\n    \n    it.count++\n    return true\n}\n```\n\n## Files to Modify\n- internal/storage/btree.go\n- internal/storage/btree_iterator.go (new)\n\n## Edge Cases\n\n| Case | Start | End | Data | Expected |\n|------|-------|-----|------|----------|\n| Empty range | 50 | 40 | [1..100] | 0 results (start \u003e end) |\n| No matches | 200 | 300 | [1..100] | 0 results |\n| Single result | 50 | 50, inclusive | [1..100] | 1 result: key=50 |\n| Full scan | nil | nil | [1..100] | 100 results |\n| Open start | nil | 10 | [1..100] | 10 results: 1-10 |\n| Open end | 90 | nil | [1..100] | 11 results: 90-100 |\n| Exclusive bounds | 10 | 20, exclusive | [1..100] | 9 results: 11-19 |\n| With Limit | nil | nil, limit=5 | [1..100] | 5 results: 1-5 |\n| Iterator after Close | - | - | - | Next() returns false, Err() nil |\n| Empty tree | nil | nil | [] | 0 results |\n\n## Test Scenarios\n\n```go\nfunc TestRangeScanBasic(t *testing.T) {\n    bt := createBTreeWithKeys(t, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    iter := bt.RangeScan(intToBytes(3), intToBytes(7), ScanOptions{\n        StartInclusive: true,\n        EndInclusive:   true,\n    })\n    defer iter.Close()\n    \n    var results []int\n    for iter.Next() {\n        results = append(results, bytesToInt(iter.Key()))\n    }\n    require.NoError(t, iter.Err())\n    assert.Equal(t, []int{3, 4, 5, 6, 7}, results)\n}\n\nfunc TestRangeScanWithLimit(t *testing.T) {\n    bt := createBTreeWithKeys(t, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    iter := bt.RangeScan(nil, nil, ScanOptions{Limit: 3})\n    defer iter.Close()\n    \n    var results []int\n    for iter.Next() {\n        results = append(results, bytesToInt(iter.Key()))\n    }\n    assert.Equal(t, []int{1, 2, 3}, results)\n}\n\nfunc TestRangeScanEmptyRange(t *testing.T) {\n    bt := createBTreeWithKeys(t, 1, 2, 3, 4, 5)\n    \n    // Start \u003e End\n    iter := bt.RangeScan(intToBytes(10), intToBytes(5), ScanOptions{})\n    assert.False(t, iter.Next())\n    assert.NoError(t, iter.Err())\n}\n\nfunc TestRangeScanUsessSiblingPointers(t *testing.T) {\n    // Insert enough to have multiple leaves\n    bt := createBTreeWithKeys(t, rangeSlice(1, 300)...)\n    \n    iter := bt.RangeScan(intToBytes(50), intToBytes(250), ScanOptions{\n        StartInclusive: true,\n        EndInclusive:   true,\n    })\n    defer iter.Close()\n    \n    count := 0\n    for iter.Next() {\n        count++\n    }\n    assert.Equal(t, 201, count) // 50 to 250 inclusive\n    \n    // Verify we used sibling pointers (not re-traversing)\n    // This would be verified by checking we didn't call Search() multiple times\n    // or by counting page reads\n}\n```\n\n## Performance Requirement\nRange scan of K keys in tree of N total keys must be O(log N + K), not O(K log N).\n\nSimple verification:\n```go\nfunc BenchmarkRangeScan(b *testing.B) {\n    bt := createBTreeWithKeys(b, rangeSlice(1, 100000)...)\n    \n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        iter := bt.RangeScan(intToBytes(1000), intToBytes(2000), ScanOptions{})\n        for iter.Next() {}\n        iter.Close()\n    }\n    // Should be ~same speed regardless of tree size if O(log N + K)\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Iterator interface defined\ngrep -n \"type BTreeIterator interface\" internal/storage/btree*.go\n# Expected: Shows interface definition\n\n# 2. RangeScan method exists\ngrep -n \"func (bt \\*BTree) RangeScan\" internal/storage/btree*.go\n# Expected: Shows method signature\n\n# 3. Uses sibling pointers\ngrep -n \"nextLeaf\" internal/storage/btree_iterator.go\n# Expected: Shows sibling pointer usage\n\n# 4. All tests pass\ngo test ./internal/storage/... -v -run TestRangeScan\n# Expected: All PASS\n\n# 5. No regression in existing tests\ngo test ./internal/storage/... -v\n# Expected: All PASS\n```\n\n## Definition of Done\n- [ ] `BTreeIterator` interface exists with `Next()`, `Key()`, `Value()`, `Err()`, `Close()`\n- [ ] `RangeScan(start, end []byte, opts ScanOptions) BTreeIterator` method on BTree\n- [ ] Iterator follows `nextLeaf` pointers (no tree re-traversal per key)\n- [ ] All 10 edge cases from table handled correctly\n- [ ] `TestRangeScanBasic` passes: correct keys in range\n- [ ] `TestRangeScanWithLimit` passes: stops at limit\n- [ ] `TestRangeScanEmptyRange` passes: no results for invalid range\n- [ ] Benchmark shows O(log N + K) behavior (not O(K log N))","status":"closed","priority":2,"issue_type":"feature","assignee":"claudedb/polecats/capable","created_at":"2026-01-05T05:39:29.016147-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:26:01.677179-07:00","closed_at":"2026-01-07T14:26:01.677179-07:00","close_reason":"Implemented B-tree range scans with Limit, StartInclusive options, RangeScan method, and comprehensive edge case tests. All tests pass.","dependencies":[{"issue_id":"cdb-loe","depends_on_id":"cdb-a0f","type":"blocks","created_at":"2026-01-05T05:51:21.108895-07:00","created_by":"cabewaldrop"}]}
{"id":"cdb-lyg","title":"Use ScanWithFilter for early filtering","description":"The table.go already has ScanWithFilter() (line 322) but executor never uses it. Wire this up to reduce memory and enable early exit.\n\n## Current Behavior\n- executor.go lines 305-316 filter in memory AFTER loading all rows\n- All rows allocated even if only 1 matches\n\n## Implementation\n1. Instead of: rows := tbl.Scan(); filter(rows)\n2. Do: rows := tbl.ScanWithFilter(predicate)\n3. Filter while scanning, reduce allocations\n4. Can exit early when LIMIT is satisfied\n\n## Files\n- internal/sql/executor/executor.go\n- internal/table/table.go (ScanWithFilter already exists!)\n\n## Acceptance Criteria\n- SELECT with WHERE uses ScanWithFilter\n- Memory allocation reduced for selective queries\n- LIMIT queries can exit early","status":"closed","priority":1,"issue_type":"task","assignee":"claudedb/polecats/dag","created_at":"2026-01-07T12:19:05.355156-07:00","created_by":"mayor","updated_at":"2026-01-07T15:12:02.032133-07:00","closed_at":"2026-01-07T15:12:02.032133-07:00","close_reason":"Already implemented and merged to main"}
{"id":"cdb-m45","title":"Create database connection middleware","description":"## Problem\nHTTP handlers need access to the SQL executor to run queries.\n\n## Solution\nCreate middleware that injects the executor into request context.\n\n## Implementation\n\n```go\n// internal/web/middleware.go\npackage web\n\nimport (\n    \"context\"\n    \"net/http\"\n    \n    \"github.com/your/claudedb/internal/sql/executor\"\n)\n\ntype contextKey string\n\nconst executorKey contextKey = \"executor\"\n\n// WithExecutor middleware injects the SQL executor into request context\nfunc WithExecutor(exec *executor.Executor) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            ctx := context.WithValue(r.Context(), executorKey, exec)\n            next.ServeHTTP(w, r.WithContext(ctx))\n        })\n    }\n}\n\n// GetExecutor retrieves the executor from request context\nfunc GetExecutor(r *http.Request) *executor.Executor {\n    exec, ok := r.Context().Value(executorKey).(*executor.Executor)\n    if \\!ok {\n        return nil\n    }\n    return exec\n}\n\n// RequireExecutor middleware returns 500 if executor not in context\nfunc RequireExecutor(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        if GetExecutor(r) == nil {\n            http.Error(w, \"Database not available\", http.StatusInternalServerError)\n            return\n        }\n        next.ServeHTTP(w, r)\n    })\n}\n```\n\n## Files to Create\n- internal/web/middleware.go\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Executor not set | RequireExecutor returns 500 |\n| Nil executor passed | GetExecutor returns nil |\n| Context cancelled mid-request | Executor query should respect context |\n| Multiple DB connections | Each request gets same executor instance |\n\n## Test Scenarios\n\n```go\nfunc TestWithExecutorMiddleware(t *testing.T) {\n    exec := setupTestExecutor(t)\n    \n    handler := WithExecutor(exec)(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        got := GetExecutor(r)\n        assert.NotNil(t, got)\n        assert.Equal(t, exec, got)\n        w.WriteHeader(200)\n    }))\n    \n    req := httptest.NewRequest(\"GET\", \"/\", nil)\n    rec := httptest.NewRecorder()\n    handler.ServeHTTP(rec, req)\n    \n    assert.Equal(t, 200, rec.Code)\n}\n\nfunc TestRequireExecutorRejects(t *testing.T) {\n    handler := RequireExecutor(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        t.Fatal(\"should not reach handler\")\n    }))\n    \n    req := httptest.NewRequest(\"GET\", \"/\", nil)\n    rec := httptest.NewRecorder()\n    handler.ServeHTTP(rec, req)\n    \n    assert.Equal(t, 500, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"Database not available\")\n}\n\nfunc TestGetExecutorWithoutMiddleware(t *testing.T) {\n    req := httptest.NewRequest(\"GET\", \"/\", nil)\n    exec := GetExecutor(req)\n    assert.Nil(t, exec)\n}\n```\n\n## Definition of Done\n- [ ] WithExecutor middleware function exists\n- [ ] GetExecutor helper retrieves from context\n- [ ] RequireExecutor middleware returns 500 if missing\n- [ ] Server.routes() applies WithExecutor to router\n- [ ] TestWithExecutorMiddleware passes\n- [ ] TestRequireExecutorRejects passes\n- [ ] TestGetExecutorWithoutMiddleware passes\n","status":"closed","priority":1,"issue_type":"task","assignee":"nux","created_at":"2026-01-07T16:53:05.845296-07:00","created_by":"mayor","updated_at":"2026-01-07T17:21:40.215832-07:00","closed_at":"2026-01-07T17:21:40.215832-07:00","close_reason":"Implemented WithExecutor, GetExecutor, RequireExecutor middleware for context-based dependency injection","dependencies":[{"issue_id":"cdb-m45","depends_on_id":"cdb-4i4","type":"blocks","created_at":"2026-01-07T16:56:17.279482-07:00","created_by":"mayor"}]}
{"id":"cdb-m4l","title":"Table struct is not thread-safe, concurrent Inserts cause race conditions","description":"## Problem\n\nThe `Table` struct has no synchronization. Concurrent `Insert()` calls will cause race conditions leading to duplicate row IDs and data corruption.\n\n## Root Cause\n\n**table.go:181-192** - No mutex in struct:\n```go\ntype Table struct {\n    Name   string\n    Schema *Schema\n    pager        *storage.Pager\n    btree        *storage.BTree\n    nextRowID    uint64        // Not protected!\n    dataPageIDs  []uint32      // Not protected!\n    metadataPage uint32\n}\n```\n\n**table.go:269-270** - Non-atomic increment:\n```go\nrowID := t.nextRowID\nt.nextRowID++\n```\n\n## Race Condition Example\n\n```\nGoroutine A                 Goroutine B\n\nread nextRowID (1)\n                            read nextRowID (1)   same value!\nnextRowID++ (now 2)\n                            nextRowID++ (now 2)\nreturn rowID=1\n                            return rowID=1   DUPLICATE!\n```\n\n## Impact\n\n- Duplicate row IDs\n- Data corruption\n- Potential panics from concurrent slice/map access\n\n## Suggested Fix\n\nAdd a mutex to protect all Table operations:\n\n```go\ntype Table struct {\n    mu sync.Mutex  // or sync.RWMutex for concurrent reads\n    // ... other fields\n}\n\nfunc (t *Table) Insert(values []Value) (uint64, error) {\n    t.mu.Lock()\n    defer t.mu.Unlock()\n    \n    rowID := t.nextRowID\n    t.nextRowID++\n    // ... rest of insert\n}\n\nfunc (t *Table) Scan() ([]Row, error) {\n    t.mu.Lock()  // or RLock() with RWMutex\n    defer t.mu.Unlock()\n    // ...\n}\n```\n\nUsing a mutex over atomics because Insert also modifies:\n- `dataPageIDs` (slice append)\n- `btree` (tree operations)\n\nThese all need protection, so a single mutex is cleaner than multiple atomics.\n\n## Files Affected\n\n- internal/table/table.go","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-04T06:13:27.675822-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T14:39:39.046547-07:00","closed_at":"2026-01-07T14:39:39.046547-07:00","close_reason":"Fixed: Added sync.RWMutex to Table struct, protected all methods with appropriate locks, added concurrent insert test that passes with race detector"}
{"id":"cdb-mgk","title":"test-task-real","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T15:46:29.693175-07:00","created_by":"mayor","updated_at":"2026-01-07T15:46:37.612337-07:00","closed_at":"2026-01-07T15:46:37.612337-07:00","close_reason":"test"}
{"id":"cdb-mvy","title":"Web UI for claudedb","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T16:52:38.882651-07:00","created_by":"mayor","updated_at":"2026-01-07T16:52:38.882651-07:00","dependencies":[{"issue_id":"cdb-mvy","depends_on_id":"cdb-28k","type":"blocks","created_at":"2026-01-07T16:56:09.133535-07:00","created_by":"mayor"},{"issue_id":"cdb-mvy","depends_on_id":"cdb-e33","type":"blocks","created_at":"2026-01-07T16:56:09.173861-07:00","created_by":"mayor"},{"issue_id":"cdb-mvy","depends_on_id":"cdb-pbn","type":"blocks","created_at":"2026-01-07T16:56:09.212606-07:00","created_by":"mayor"},{"issue_id":"cdb-mvy","depends_on_id":"cdb-9hz","type":"blocks","created_at":"2026-01-07T16:56:09.250886-07:00","created_by":"mayor"},{"issue_id":"cdb-mvy","depends_on_id":"cdb-g1w","type":"blocks","created_at":"2026-01-07T16:56:09.291978-07:00","created_by":"mayor"}]}
{"id":"cdb-mx2","title":"Delete row with confirmation","description":"## Problem\nUsers need to delete rows without writing DELETE statements.\n\n## Solution\nDELETE endpoint with confirmation dialog via HTMX.\n\n## Implementation\n\n```go\nfunc (s *Server) handleDeleteRow(w http.ResponseWriter, r *http.Request) {\n    tableName := chi.URLParam(r, \"name\")\n    pkValue := chi.URLParam(r, \"pk\")\n    exec := GetExecutor(r)\n    \n    schema, err := exec.GetTableSchema(tableName)\n    if err != nil {\n        http.Error(w, \"Table not found\", 404)\n        return\n    }\n    \n    pkCol := getPrimaryKeyColumn(schema)\n    if pkCol == \"\" {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Table has no primary key - cannot delete specific rows\",\n        })\n        return\n    }\n    \n    sql := fmt.Sprintf(\"DELETE FROM %s WHERE %s = %s\", tableName, pkCol, pkValue)\n    \n    result, err := exec.Execute(sql)\n    if err != nil {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": err.Error(),\n        })\n        return\n    }\n    \n    if result.RowsAffected == 0 {\n        renderTemplate(w, \"partials/error.html\", map[string]string{\n            \"Error\": \"Row not found - may have already been deleted\",\n        })\n        return\n    }\n    \n    // Return empty response to remove row from DOM (hx-swap=\"outerHTML\")\n    w.WriteHeader(200)\n    w.Write([]byte(\"\u003c!-- Row deleted --\u003e\"))\n}\n```\n\nThe delete button is already in table_data.html:\n```html\n\u003cbutton hx-delete=\"/tables/{{$.Table}}/{{.PrimaryKey}}\"\n        hx-confirm=\"Delete this row?\"\n        hx-target=\"closest tr\"\n        hx-swap=\"outerHTML\"\n        class=\"btn-small btn-danger\"\u003eDelete\u003c/button\u003e\n```\n\n## Files to Modify\n- internal/web/handlers.go (handleDeleteRow)\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Table without primary key | Error \"cannot delete - no PK\" |\n| Row already deleted | Error \"row not found\" |\n| Delete violates FK constraint | SQL error displayed |\n| Concurrent delete | First succeeds, second gets \"not found\" |\n| Delete all rows | Each delete works independently |\n| JavaScript disabled | hx-confirm falls back to browser confirm |\n\n## Test Scenarios\n\n```go\nfunc TestDeleteRowSuccess(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    exec.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    exec.Execute(\"INSERT INTO users VALUES (2, 'Bob')\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    req, _ := http.NewRequest(http.MethodDelete, ts.URL+\"/tables/users/1\", nil)\n    resp, err := http.DefaultClient.Do(req)\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    // Verify deleted\n    result, _ := exec.Execute(\"SELECT COUNT(*) FROM users\")\n    assert.Equal(t, 1, result.Rows[0][0].(int))\n    \n    result, _ = exec.Execute(\"SELECT * FROM users WHERE id = 1\")\n    assert.Equal(t, 0, len(result.Rows))\n}\n\nfunc TestDeleteRowNotFound(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    req, _ := http.NewRequest(http.MethodDelete, ts.URL+\"/tables/users/999\", nil)\n    resp, err := http.DefaultClient.Do(req)\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"not found\")\n}\n\nfunc TestDeleteRowNoPrimaryKey(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE data (value TEXT)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    req, _ := http.NewRequest(http.MethodDelete, ts.URL+\"/tables/data/1\", nil)\n    resp, err := http.DefaultClient.Do(req)\n    require.NoError(t, err)\n    \n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"no primary key\")\n}\n\nfunc TestDeleteRowIdempotent(t *testing.T) {\n    exec := setupTestExecutor(t)\n    exec.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY)\")\n    exec.Execute(\"INSERT INTO users VALUES (1)\")\n    \n    srv := NewServer(0, exec)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    // First delete\n    req, _ := http.NewRequest(http.MethodDelete, ts.URL+\"/tables/users/1\", nil)\n    resp, _ := http.DefaultClient.Do(req)\n    assert.Equal(t, 200, resp.StatusCode)\n    \n    // Second delete (already gone)\n    req, _ = http.NewRequest(http.MethodDelete, ts.URL+\"/tables/users/1\", nil)\n    resp, _ = http.DefaultClient.Do(req)\n    body, _ := io.ReadAll(resp.Body)\n    assert.Contains(t, string(body), \"not found\")\n}\n```\n\n## Definition of Done\n- [ ] DELETE /tables/{name}/{pk} endpoint implemented\n- [ ] Confirmation via hx-confirm before delete\n- [ ] Row removed from DOM on success (hx-swap=\"outerHTML\" with empty)\n- [ ] Error for tables without primary key\n- [ ] Error for row not found\n- [ ] SQL injection prevented (pk value validated)\n- [ ] TestDeleteRowSuccess passes\n- [ ] TestDeleteRowNotFound passes\n- [ ] TestDeleteRowNoPrimaryKey passes\n- [ ] TestDeleteRowIdempotent passes\n","status":"closed","priority":2,"issue_type":"task","assignee":"dementus","created_at":"2026-01-07T16:55:41.010388-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:36.067834-07:00","closed_at":"2026-01-07T17:32:36.067834-07:00","close_reason":"Implemented DELETE /tables/{name}/{pk} endpoint with HTMX support"}
{"id":"cdb-mxq","title":"Session ended: gt-claudedb-capable","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:32:58.191879-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T17:32:58.191879-07:00"}
{"id":"cdb-nk5","title":"Session ended: gt-claudedb-dementus","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:33:34.244437-07:00","created_by":"claudedb/polecats/dementus","updated_at":"2026-01-07T17:33:34.244437-07:00"}
{"id":"cdb-obt","title":"Session ended: gt-claudedb-nux","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:22:11.350744-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:22:11.350744-07:00"}
{"id":"cdb-ok3","title":"Test prefix parsing","description":"Test","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T13:59:37.048287-07:00","created_by":"mayor","updated_at":"2026-01-07T14:05:19.908548-07:00","closed_at":"2026-01-07T13:59:43.871246-07:00","close_reason":"Closed"}
{"id":"cdb-pbn","title":"Table Metadata Views","description":"View database metadata: list tables, show table schemas, preview table data.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T16:52:48.389986-07:00","created_by":"mayor","updated_at":"2026-01-07T17:32:49.596081-07:00","closed_at":"2026-01-07T17:32:49.596081-07:00","close_reason":"All child tasks complete: list tables, schema view, data preview","dependencies":[{"issue_id":"cdb-pbn","depends_on_id":"cdb-28k","type":"blocks","created_at":"2026-01-07T16:56:02.138511-07:00","created_by":"mayor"},{"issue_id":"cdb-pbn","depends_on_id":"cdb-5j0","type":"blocks","created_at":"2026-01-07T16:56:34.672743-07:00","created_by":"mayor"},{"issue_id":"cdb-pbn","depends_on_id":"cdb-huu","type":"blocks","created_at":"2026-01-07T16:56:34.714091-07:00","created_by":"mayor"},{"issue_id":"cdb-pbn","depends_on_id":"cdb-gj1","type":"blocks","created_at":"2026-01-07T16:56:34.755498-07:00","created_by":"mayor"}]}
{"id":"cdb-pxo","title":"CSS styling and layout","description":"## Problem\nThe UI needs consistent, clean styling without heavy frameworks.\n\n## Solution\nMinimal CSS using modern techniques, optionally with Pico CSS base.\n\n## Implementation\n\n```css\n/* internal/web/static/style.css */\n\n/* === Reset \u0026 Base === */\n*, *::before, *::after {\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: system-ui, -apple-system, sans-serif;\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n    background: #f5f5f5;\n    color: #333;\n}\n\n/* === Layout === */\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 1rem;\n}\n\n/* === Navigation === */\n.navbar {\n    background: #2c3e50;\n    color: white;\n    padding: 0.75rem 1rem;\n    display: flex;\n    align-items: center;\n    gap: 2rem;\n}\n\n.navbar .brand {\n    font-weight: bold;\n    font-size: 1.25rem;\n    color: white;\n    text-decoration: none;\n}\n\n.navbar ul {\n    display: flex;\n    gap: 1rem;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n}\n\n.navbar a {\n    color: rgba(255,255,255,0.8);\n    text-decoration: none;\n}\n\n.navbar a:hover {\n    color: white;\n}\n\n/* === Tables === */\ntable {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.1);\n}\n\nth, td {\n    padding: 0.75rem;\n    text-align: left;\n    border-bottom: 1px solid #dee2e6;\n}\n\nth {\n    background: #f8f9fa;\n    font-weight: 600;\n}\n\ntr:hover {\n    background: #f8f9fa;\n}\n\n.table-wrapper {\n    overflow-x: auto;\n}\n\n/* === Forms === */\n.form-group {\n    margin-bottom: 1rem;\n}\n\nlabel {\n    display: block;\n    margin-bottom: 0.25rem;\n    font-weight: 500;\n}\n\ninput[type=\"text\"],\ninput[type=\"number\"],\ntextarea,\nselect {\n    width: 100%;\n    padding: 0.5rem;\n    border: 1px solid #ced4da;\n    border-radius: 4px;\n    font-size: 1rem;\n}\n\ntextarea {\n    min-height: 150px;\n    font-family: monospace;\n}\n\ninput:focus,\ntextarea:focus,\nselect:focus {\n    outline: none;\n    border-color: #007bff;\n    box-shadow: 0 0 0 2px rgba(0,123,255,0.25);\n}\n\n/* === Buttons === */\n.btn, button {\n    display: inline-block;\n    padding: 0.5rem 1rem;\n    border: 1px solid transparent;\n    border-radius: 4px;\n    font-size: 1rem;\n    cursor: pointer;\n    text-decoration: none;\n    background: #6c757d;\n    color: white;\n}\n\n.btn:hover, button:hover {\n    opacity: 0.9;\n}\n\n.btn-primary {\n    background: #007bff;\n}\n\n.btn-secondary {\n    background: #6c757d;\n}\n\n.btn-danger {\n    background: #dc3545;\n}\n\n.btn-small {\n    padding: 0.25rem 0.5rem;\n    font-size: 0.875rem;\n}\n\n/* === Badges === */\n.badge {\n    display: inline-block;\n    padding: 0.125rem 0.375rem;\n    font-size: 0.75rem;\n    border-radius: 3px;\n    font-weight: 600;\n}\n\n.badge.pk { background: #007bff; color: white; }\n.badge.nn { background: #6c757d; color: white; }\n.badge.uq { background: #28a745; color: white; }\n.badge.required { background: #ffc107; color: #333; }\n\n/* === Alerts \u0026 Messages === */\n.query-error {\n    background: #f8d7da;\n    border: 1px solid #f5c6cb;\n    color: #721c24;\n    padding: 1rem;\n    border-radius: 4px;\n    margin: 1rem 0;\n}\n\n.query-results .results-meta {\n    color: #6c757d;\n    margin-bottom: 0.5rem;\n}\n\n.null {\n    color: #6c757d;\n    font-style: italic;\n}\n\n/* === Breadcrumb === */\n.breadcrumb {\n    margin-bottom: 1rem;\n    color: #6c757d;\n}\n\n.breadcrumb a {\n    color: #007bff;\n}\n\n/* === HTMX Loading === */\n.htmx-indicator {\n    display: none;\n}\n\n.htmx-request .htmx-indicator {\n    display: inline;\n}\n\n.htmx-request.htmx-indicator {\n    display: inline;\n}\n\n/* === Responsive === */\n@media (max-width: 768px) {\n    .navbar {\n        flex-direction: column;\n        align-items: flex-start;\n    }\n    \n    .form-actions {\n        flex-direction: column;\n    }\n    \n    .btn {\n        width: 100%;\n        text-align: center;\n    }\n}\n```\n\n## Files to Create\n- internal/web/static/style.css\n\n## Edge Cases\n\n| Case | Expected Behavior |\n|------|-------------------|\n| Very wide table | Horizontal scroll wrapper |\n| Mobile screen | Stack navigation, full-width buttons |\n| Long text in cell | Truncate or wrap based on context |\n| Dark mode | Not required for MVP, but use CSS vars for future |\n| Print | Hide nav, keep content readable |\n\n## Test Scenarios\n\n```go\nfunc TestCSSFileServed(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, err := http.Get(ts.URL + \"/static/style.css\")\n    require.NoError(t, err)\n    assert.Equal(t, 200, resp.StatusCode)\n    assert.Contains(t, resp.Header.Get(\"Content-Type\"), \"css\")\n    \n    body, _ := io.ReadAll(resp.Body)\n    css := string(body)\n    assert.Contains(t, css, \".navbar\")\n    assert.Contains(t, css, \".btn-primary\")\n    assert.Contains(t, css, \"border-collapse\")\n}\n\nfunc TestResponsiveBreakpoints(t *testing.T) {\n    srv := NewServer(0, nil)\n    ts := httptest.NewServer(srv.router)\n    defer ts.Close()\n    \n    resp, _ := http.Get(ts.URL + \"/static/style.css\")\n    body, _ := io.ReadAll(resp.Body)\n    \n    assert.Contains(t, string(body), \"@media\")\n    assert.Contains(t, string(body), \"768px\")\n}\n```\n\n## Definition of Done\n- [ ] style.css created with all component styles\n- [ ] Navbar styled with brand and links\n- [ ] Tables styled with hover states\n- [ ] Forms styled with focus states\n- [ ] Buttons styled (primary, secondary, danger, small)\n- [ ] Badges for constraints (PK, NOT NULL, etc)\n- [ ] Error/success message styling\n- [ ] HTMX loading indicator support\n- [ ] Mobile responsive at 768px breakpoint\n- [ ] TestCSSFileServed passes\n- [ ] TestResponsiveBreakpoints passes\n","status":"closed","priority":3,"issue_type":"task","assignee":"toast","created_at":"2026-01-07T16:55:49.456099-07:00","created_by":"mayor","updated_at":"2026-01-07T17:33:06.536805-07:00","closed_at":"2026-01-07T17:33:06.536805-07:00","close_reason":"Completed CSS styling with all components: buttons, badges, forms, alerts, responsive breakpoints, print styles. All tests pass."}
{"id":"cdb-rib","title":"Session ended: gt-claudedb-toast","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:22:54.057267-07:00","created_by":"claudedb/polecats/toast","updated_at":"2026-01-07T17:22:54.057267-07:00"}
{"id":"cdb-tt0","title":"Session ended: gt-claudedb-cheedo","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T15:48:37.145292-07:00","created_by":"claudedb/polecats/cheedo","updated_at":"2026-01-07T15:48:37.145292-07:00"}
{"id":"cdb-uue","title":"Merge: nux-db","description":"branch: polecat/nux-db-middleware\ntarget: main\nsource_issue: nux-db\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-nux\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:21:50.29592-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T17:21:50.29592-07:00"}
{"id":"cdb-v3x","title":"Merge: dag-mk4iwbdo","description":"branch: polecat/dag-mk4iwbdo\ntarget: main\nsource_issue: dag-mk4iwbdo\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-dag\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T14:40:38.57354-07:00","created_by":"claudedb/polecats/dag","updated_at":"2026-01-07T16:09:17.936172-07:00","closed_at":"2026-01-07T16:09:17.936172-07:00","close_reason":"Already merged to main"}
{"id":"cdb-x1z","title":"test-agent-real","status":"closed","priority":2,"issue_type":"agent","created_at":"2026-01-07T15:51:02.689194-07:00","created_by":"mayor","updated_at":"2026-01-07T15:51:32.93199-07:00","closed_at":"2026-01-07T15:51:32.93199-07:00","close_reason":"test cleanup"}
{"id":"cdb-xa7","title":"LRU buffer pool eviction","description":"dispatched_by: mayor\n\nImplement bounded buffer pool with LRU eviction to prevent unbounded memory growth.\n\n## Current State\n- pager.go line 40: cache is simple unbounded map\n- Memory grows with every page accessed\n- No eviction policy\n\n## Implementation\n1. Add maxCacheSize configuration\n2. Implement LRU tracking (doubly-linked list + map)\n3. Evict least recently used pages when cache full\n4. Track dirty pages for write-back before eviction\n\n## Files\n- internal/storage/pager.go (line ~40)\n\n## Acceptance Criteria\n- Cache has configurable size limit\n- LRU eviction when limit reached\n- Dirty pages written before eviction\n- Memory usage bounded regardless of table size","status":"closed","priority":3,"issue_type":"task","assignee":"claudedb/polecats/cheedo","created_at":"2026-01-07T12:19:06.398096-07:00","created_by":"mayor","updated_at":"2026-01-07T15:47:35.743676-07:00","closed_at":"2026-01-07T15:47:35.743676-07:00","close_reason":"Closed"}
{"id":"cdb-xia","title":"Merge: valkyrie-mk4mdh49","description":"branch: polecat/valkyrie-mk4mdh49\ntarget: main\nsource_issue: valkyrie-mk4mdh49\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-valkyrie\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"open","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T17:32:22.948806-07:00","created_by":"claudedb/polecats/valkyrie","updated_at":"2026-01-07T17:32:22.948806-07:00"}
{"id":"cdb-xsr","title":"Support secondary indexes (CREATE INDEX)","description":"## Problem\nOnly primary keys are indexed. Queries on other columns always require full table scans.\n\n## Solution\nSupport CREATE INDEX / DROP INDEX for secondary indexes.\n\n## Syntax\n```sql\nCREATE INDEX idx_email ON users(email);\nCREATE UNIQUE INDEX idx_ssn ON users(ssn);\nDROP INDEX idx_email;\n```\n\n## Design\n\n### Index Metadata\n```go\ntype IndexInfo struct {\n    Name       string\n    TableName  string\n    ColumnName string\n    ColumnIdx  int\n    IsUnique   bool\n    RootPage   uint32\n}\n```\n\n### Catalog Changes\n```go\ntype Catalog struct {\n    // existing...\n    indexes map[string]map[string]*IndexInfo  // table -\u003e indexName -\u003e info\n}\n\nfunc (c *Catalog) CreateIndex(info *IndexInfo, btree *storage.BTree) error\nfunc (c *Catalog) DropIndex(tableName, indexName string) error\nfunc (c *Catalog) GetIndexes(tableName string) []*IndexInfo\nfunc (c *Catalog) GetIndex(tableName, indexName string) (*IndexInfo, bool)\n```\n\n### Table Changes\n```go\ntype Table struct {\n    // existing...\n    secondaryIndexes map[string]*storage.BTree\n    indexInfos       map[string]*IndexInfo\n}\n\nfunc (t *Table) AddIndex(info *IndexInfo, btree *storage.BTree)\nfunc (t *Table) RemoveIndex(indexName string)\nfunc (t *Table) GetIndexes() map[string]*IndexInfo\n```\n\n### Index Maintenance on DML\n\n```go\nfunc (t *Table) Insert(values []Value) (uint64, error) {\n    // Check unique constraints BEFORE insert\n    for name, idx := range t.secondaryIndexes {\n        info := t.indexInfos[name]\n        if info.IsUnique {\n            keyBytes := t.valueToBytes(values[info.ColumnIdx])\n            if _, found, _ := idx.Search(keyBytes); found {\n                return 0, fmt.Errorf(\n                    \"duplicate key value violates unique constraint \\\"%s\\\"\", name)\n            }\n        }\n    }\n    \n    // ... existing insert logic ...\n    \n    // Update all secondary indexes\n    for name, idx := range t.secondaryIndexes {\n        info := t.indexInfos[name]\n        keyBytes := t.valueToBytes(values[info.ColumnIdx])\n        if err := idx.Insert(keyBytes, location); err \\!= nil {\n            return 0, fmt.Errorf(\"failed to update index %s: %w\", name, err)\n        }\n    }\n    \n    return rowID, nil\n}\n\n// Similar for Update and Delete\n```\n\n### Executor Additions\n```go\nfunc (e *Executor) executeCreateIndex(stmt *CreateIndexStatement) (*Result, error) {\n    tbl := e.tables[stmt.TableName]\n    if tbl == nil {\n        return nil, fmt.Errorf(\"table %s does not exist\", stmt.TableName)\n    }\n    \n    colIdx, ok := tbl.Schema.GetColumnIndex(stmt.ColumnName)\n    if \\!ok {\n        return nil, fmt.Errorf(\"column %s does not exist\", stmt.ColumnName)\n    }\n    \n    // Check for duplicate index name\n    if _, exists := tbl.GetIndexes()[stmt.IndexName]; exists {\n        return nil, fmt.Errorf(\"index %s already exists\", stmt.IndexName)\n    }\n    \n    // Create B-tree for index\n    btree, err := storage.NewBTree(e.pager)\n    if err \\!= nil {\n        return nil, err\n    }\n    \n    // Populate index with existing data\n    rows, err := tbl.Scan()\n    if err \\!= nil {\n        return nil, err\n    }\n    \n    for _, row := range rows {\n        keyBytes := tbl.valueToBytes(row.Values[colIdx])\n        location := row.Location // Need to track this\n        \n        // Check unique constraint while building\n        if stmt.IsUnique {\n            if _, found, _ := btree.Search(keyBytes); found {\n                return nil, fmt.Errorf(\n                    \"could not create unique index: duplicate key found\")\n            }\n        }\n        \n        if err := btree.Insert(keyBytes, location); err \\!= nil {\n            return nil, err\n        }\n    }\n    \n    // Register index\n    info := \u0026IndexInfo{\n        Name:       stmt.IndexName,\n        TableName:  stmt.TableName,\n        ColumnName: stmt.ColumnName,\n        ColumnIdx:  colIdx,\n        IsUnique:   stmt.IsUnique,\n        RootPage:   btree.RootPage(),\n    }\n    \n    tbl.AddIndex(info, btree)\n    e.catalog.CreateIndex(info, btree)\n    \n    return \u0026Result{Message: fmt.Sprintf(\"Index '%s' created\", stmt.IndexName)}, nil\n}\n```\n\n## Files to Modify\n- internal/sql/lexer/lexer.go (INDEX, UNIQUE tokens)\n- internal/sql/parser/ast.go (CreateIndexStatement, DropIndexStatement)\n- internal/sql/parser/parser.go (parseCreateIndex, parseDropIndex)\n- internal/catalog/catalog.go (index storage)\n- internal/table/table.go (secondaryIndexes, index maintenance)\n- internal/sql/executor/executor.go (executeCreateIndex, executeDropIndex)\n- internal/sql/planner/planner.go (consider secondary indexes)\n\n## Edge Cases\n\n| Case | Scenario | Expected Behavior |\n|------|----------|-------------------|\n| Duplicate index name | CREATE INDEX foo twice | Error: \"index foo already exists\" |\n| Non-existent table | CREATE INDEX ON nosuchtable | Error: \"table nosuchtable does not exist\" |\n| Non-existent column | CREATE INDEX ON t(nocol) | Error: \"column nocol does not exist\" |\n| Drop non-existent | DROP INDEX nosuchindex | Error: \"index nosuchindex does not exist\" |\n| Unique violation on create | CREATE UNIQUE INDEX on column with duplicates | Error: \"duplicate key found\" |\n| Unique violation on insert | INSERT duplicate into unique-indexed column | Error: \"violates unique constraint\" |\n| NULL in unique index | INSERT NULL into unique column | Allowed (NULLs are distinct) |\n| Index on NULL-heavy column | Many NULL values | Index works, NULLs stored |\n| Concurrent index creation | CREATE INDEX during heavy INSERT | Acceptable race (may miss rows) |\n| Index survives restart | Create index, restart, query | Index metadata loaded from catalog |\n\n## Test Scenarios\n\n```go\nfunc TestCreateIndex(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\",\n        \"id INTEGER PRIMARY KEY, email TEXT, age INTEGER\")\n    \n    // Insert test data\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'a@b.com', 30)\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (2, 'c@d.com', 25)\"))\n    \n    // Create index\n    result, err := exec.Execute(parseSQL(\"CREATE INDEX idx_email ON users(email)\"))\n    require.NoError(t, err)\n    assert.Contains(t, result.Message, \"created\")\n    \n    // Verify index exists\n    tbl, _ := exec.GetTable(\"users\")\n    _, exists := tbl.GetIndexes()[\"idx_email\"]\n    assert.True(t, exists)\n}\n\nfunc TestUniqueIndexPreventssDuplicates(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\",\n        \"id INTEGER PRIMARY KEY, email TEXT\")\n    \n    exec.Execute(parseSQL(\"CREATE UNIQUE INDEX idx_email ON users(email)\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'a@b.com')\"))\n    \n    // Duplicate should fail\n    _, err := exec.Execute(parseSQL(\"INSERT INTO users VALUES (2, 'a@b.com')\"))\n    assert.ErrorContains(t, err, \"unique constraint\")\n}\n\nfunc TestDropIndex(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \"id INTEGER PRIMARY KEY, name TEXT\")\n    exec.Execute(parseSQL(\"CREATE INDEX idx_name ON users(name)\"))\n    \n    result, err := exec.Execute(parseSQL(\"DROP INDEX idx_name\"))\n    require.NoError(t, err)\n    assert.Contains(t, result.Message, \"dropped\")\n    \n    // Index should no longer exist\n    tbl, _ := exec.GetTable(\"users\")\n    _, exists := tbl.GetIndexes()[\"idx_name\"]\n    assert.False(t, exists)\n}\n\nfunc TestIndexUsedByPlanner(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\",\n        \"id INTEGER PRIMARY KEY, email TEXT\")\n    exec.Execute(parseSQL(\"CREATE INDEX idx_email ON users(email)\"))\n    \n    // Query on indexed column should use index\n    result, _ := exec.Execute(parseSQL(\n        \"EXPLAIN SELECT * FROM users WHERE email = 'test@test.com'\"))\n    \n    assert.Contains(t, result.Message, \"IndexScan\")\n    assert.Contains(t, result.Message, \"idx_email\")\n}\n\nfunc TestIndexMaintainedOnInsert(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\",\n        \"id INTEGER PRIMARY KEY, email TEXT\")\n    exec.Execute(parseSQL(\"CREATE INDEX idx_email ON users(email)\"))\n    \n    // Insert after index creation\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'new@email.com')\"))\n    \n    // Query should find the new row via index\n    result, _ := exec.Execute(parseSQL(\n        \"SELECT * FROM users WHERE email = 'new@email.com'\"))\n    assert.Equal(t, 1, len(result.Rows))\n}\n\nfunc TestIndexSurvivesRestart(t *testing.T) {\n    dbPath := t.TempDir() + \"/test.db\"\n    \n    // Create, populate, close\n    exec1 := openDatabase(dbPath)\n    exec1.Execute(parseSQL(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT)\"))\n    exec1.Execute(parseSQL(\"CREATE INDEX idx_email ON users(email)\"))\n    exec1.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'test@test.com')\"))\n    exec1.Close()\n    \n    // Reopen and verify\n    exec2 := openDatabase(dbPath)\n    result, err := exec2.Execute(parseSQL(\n        \"EXPLAIN SELECT * FROM users WHERE email = 'test@test.com'\"))\n    require.NoError(t, err)\n    assert.Contains(t, result.Message, \"idx_email\")\n    exec2.Close()\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. CREATE INDEX parses\necho \"CREATE INDEX idx ON t(col)\" | go run ./cmd/claude-db/ 2\u003e\u00261 | grep -v \"error\"\n# Expected: No parse error\n\n# 2. IndexInfo struct exists  \ngrep -n \"type IndexInfo struct\" internal/catalog/catalog.go\n# Expected: Shows struct definition\n\n# 3. Index maintenance in Insert\ngrep -n \"secondaryIndexes\" internal/table/table.go | head -5\n# Expected: Shows secondary index handling\n\n# 4. Planner considers secondary indexes\ngrep -n \"GetIndexes\" internal/sql/planner/planner.go\n# Expected: Shows planner checking for indexes\n\n# 5. All tests pass\ngo test ./... -v -run \"TestCreateIndex\\|TestUniqueIndex\\|TestDropIndex\\|TestIndexUsed\\|TestIndexMaintained\\|TestIndexSurvives\"\n# Expected: All PASS\n```\n\n## Definition of Done\n- [ ] `CREATE INDEX name ON table(column)` parses and executes\n- [ ] `CREATE UNIQUE INDEX` enforces uniqueness\n- [ ] `DROP INDEX name` removes index\n- [ ] `IndexInfo` stored in catalog, survives restart\n- [ ] `Table.Insert()` updates all secondary indexes\n- [ ] `Table.Delete()` removes from all secondary indexes  \n- [ ] `Table.Update()` updates indexes when indexed column changes\n- [ ] Query planner considers secondary indexes for WHERE clauses\n- [ ] `TestCreateIndex` passes: index created and registered\n- [ ] `TestUniqueIndexPreventssDuplicates` passes: unique constraint works\n- [ ] `TestDropIndex` passes: index removed\n- [ ] `TestIndexUsedByPlanner` passes: EXPLAIN shows index usage\n- [ ] `TestIndexMaintainedOnInsert` passes: new rows findable via index\n- [ ] `TestIndexSurvivesRestart` passes: persistence works","status":"closed","priority":3,"issue_type":"feature","assignee":"claudedb/polecats/nux","created_at":"2026-01-05T05:39:34.262975-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T16:30:36.71156-07:00","closed_at":"2026-01-07T16:30:36.71156-07:00","close_reason":"Implemented secondary indexes with CREATE INDEX/DROP INDEX support","dependencies":[{"issue_id":"cdb-xsr","depends_on_id":"cdb-goh","type":"blocks","created_at":"2026-01-05T05:40:24.34279-07:00","created_by":"cabewaldrop"},{"issue_id":"cdb-xsr","depends_on_id":"cdb-loe","type":"blocks","created_at":"2026-01-05T05:40:29.579778-07:00","created_by":"cabewaldrop"},{"issue_id":"cdb-xsr","depends_on_id":"cdb-au8","type":"blocks","created_at":"2026-01-05T05:51:26.363511-07:00","created_by":"cabewaldrop"}]}
{"id":"cdb-xyz","title":"Test force","description":"Test","status":"tombstone","priority":2,"issue_type":"task","created_at":"2026-01-07T14:04:23.235005-07:00","created_by":"mayor","updated_at":"2026-01-07T14:04:47.014839-07:00","close_reason":"Closed","deleted_at":"2026-01-07T14:04:47.014839-07:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"cdb-yds","title":"Session ended: gt-claudedb-dag","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:20:08.404626-07:00","created_by":"claudedb/polecats/dag","updated_at":"2026-01-07T17:20:08.404626-07:00"}
{"id":"cdb-zpa","title":"Session ended: gt-claudedb-valkyrie","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T17:32:42.488826-07:00","created_by":"claudedb/polecats/valkyrie","updated_at":"2026-01-07T17:32:42.488826-07:00"}
{"id":"cdb-zpc","title":"Session ended: gt-claudedb-capable","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T14:26:42.468596-07:00","created_by":"claudedb/polecats/capable","updated_at":"2026-01-07T14:26:42.468596-07:00"}
{"id":"cdb-zq7","title":"Merge: nux-secondary","description":"branch: polecat/nux-secondary-indexes\ntarget: main\nsource_issue: nux-secondary\nrig: claudedb\nagent_bead: cdb-claudedb-polecat-nux\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null","status":"closed","priority":2,"issue_type":"merge-request","created_at":"2026-01-07T16:30:50.451235-07:00","created_by":"claudedb/polecats/nux","updated_at":"2026-01-07T16:43:44.23414-07:00","closed_at":"2026-01-07T16:43:44.23414-07:00","close_reason":"Merged to main"}
{"id":"cdb-zr6","title":"Session ended: gt-claudedb-furiosa","status":"open","priority":2,"issue_type":"event","created_at":"2026-01-07T16:24:22.435268-07:00","created_by":"claudedb/polecats/furiosa","updated_at":"2026-01-07T16:24:22.435268-07:00"}
{"id":"claude-db-0gq","title":"Secondary index support (CREATE INDEX)","description":"Add support for creating and using secondary indexes on non-PK columns.\n\n## Current State\n- Only primary key has an index\n- README lists 'Indexes beyond primary key' as a limitation\n\n## Implementation\n1. Add CREATE INDEX statement to parser\n2. Extend Table struct with indexes map[string]*BTree\n3. Maintain secondary indexes on INSERT/UPDATE/DELETE\n4. Query planner selects best index for WHERE clause\n\n## Syntax\n```sql\nCREATE INDEX users_age ON users(age);\nSELECT * FROM users WHERE age \u003e 30;  -- Uses index\n```\n\n## Files\n- internal/sql/parser/parser.go (new statement type)\n- internal/sql/ast/ast.go (CreateIndexStatement)\n- internal/table/table.go (multiple index support)\n- internal/sql/executor/executor.go (CREATE INDEX execution)\n- internal/sql/planner/ (index selection)\n\n## Acceptance Criteria\n- CREATE INDEX syntax works\n- Secondary indexes maintained on writes\n- Planner can choose secondary index for queries","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T12:19:05.789451-07:00","created_by":"mayor","updated_at":"2026-01-07T12:21:32.935096-07:00","closed_at":"2026-01-07T12:21:32.935096-07:00","close_reason":"Superseded by existing claude-db-xsr (Support secondary indexes) which has full implementation plan including catalog changes, DML maintenance, and persistence","dependencies":[{"issue_id":"claude-db-0gq","depends_on_id":"claude-db-2tp","type":"blocks","created_at":"2026-01-07T12:19:19.610572-07:00","created_by":"mayor"}]}
{"id":"claude-db-2tp","title":"Create query planner package","description":"Build a query planner that analyzes queries and chooses optimal execution strategy.\n\n## Current State\n- executor.go comment mentions planning but no planner exists\n- All queries go directly to execution with full scan\n\n## Implementation\n1. Create internal/sql/planner/ package\n2. Define QueryPlan interface with Execute() method\n3. Implement plan types:\n   - FullTableScan\n   - IndexScan (PK lookup)\n   - FilteredScan\n4. Planner analyzes WHERE clause + available indexes\n5. Executor calls planner.BuildPlan() then plan.Execute()\n\n## Example\n```go\ntype QueryPlan interface {\n    Execute(table *Table) ([]Row, error)\n}\n\ntype IndexScan struct {\n    index *BTree\n    key   []byte\n}\n\n// Usage in executor:\nplan := planner.BuildPlan(stmt, table)\nrows := plan.Execute(table)\n```\n\n## Files\n- NEW: internal/sql/planner/planner.go\n- NEW: internal/sql/planner/plans.go\n- MODIFY: internal/sql/executor/executor.go\n\n## Acceptance Criteria\n- Query planner package exists\n- Executor delegates access path choice to planner\n- Foundation for cost-based optimization","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T12:19:05.567201-07:00","created_by":"mayor","updated_at":"2026-01-07T12:21:32.770777-07:00","closed_at":"2026-01-07T12:21:32.770777-07:00","close_reason":"Superseded by existing claude-db-goh (Add query planner to analyze WHERE clauses) which has detailed design, edge cases, and test scenarios","dependencies":[{"issue_id":"claude-db-2tp","depends_on_id":"claude-db-epo","type":"blocks","created_at":"2026-01-07T12:19:19.419696-07:00","created_by":"mayor"}]}
{"id":"claude-db-5jc","title":"Add Table.GetRowByLocation() for index lookups","description":"## Problem\nThe B-tree `Search()` returns a row location as `(pageID \u003c\u003c 32 | offset)`, but Table has no method to retrieve a row by this location. This is a fundamental building block needed before any index-based query optimization can work.\n\n## Solution\nAdd a method to retrieve a single row by its physical location:\n\n```go\n// GetRowByLocation retrieves a row using the location from B-tree lookup.\n// Location format: (pageID \u003c\u003c 32) | offset\nfunc (t *Table) GetRowByLocation(location uint64) (Row, error) {\n    pageID := uint32(location \u003e\u003e 32)\n    offset := uint16(location \u0026 0xFFFF)\n    \n    page, err := t.pager.GetPage(pageID)\n    if err != nil {\n        return Row{}, fmt.Errorf(\"page %d not found: %w\", pageID, err)\n    }\n    \n    data := page.GetData()\n    if int(offset) \u003e= len(data)-1 {\n        return Row{}, fmt.Errorf(\"offset %d out of bounds for page %d\", offset, pageID)\n    }\n    \n    length := binary.LittleEndian.Uint16(data[offset:])\n    if length == 0 {\n        return Row{}, fmt.Errorf(\"invalid row at offset %d: zero length\", offset)\n    }\n    \n    endOffset := int(offset) + 2 + int(length)\n    if endOffset \u003e len(data) {\n        return Row{}, fmt.Errorf(\"row data exceeds page boundary\")\n    }\n    \n    rowData := data[offset+2 : endOffset]\n    return t.deserializeRow(rowData)\n}\n```\n\n## Files to Modify\n- internal/table/table.go\n\n## Edge Cases\n\n| Case | Input | Expected Behavior |\n|------|-------|-------------------|\n| Zero location | `location = 0` | Error: \"page 0 not found\" or valid if page 0 exists |\n| Invalid page ID | `pageID = 999999` | Error: \"page 999999 not found: ...\" |\n| Offset past data | `offset \u003e len(page.data)` | Error: \"offset N out of bounds for page M\" |\n| Zero-length row | `length = 0` at offset | Error: \"invalid row at offset N: zero length\" |\n| Row exceeds page | `offset + length \u003e pageSize` | Error: \"row data exceeds page boundary\" |\n| Valid location | Normal B-tree lookup result | Returns correct Row with matching ID |\n\n## Test Scenarios\n\n```go\nfunc TestGetRowByLocation(t *testing.T) {\n    // Setup: Create table, insert row, get location from B-tree\n    tbl := createTestTable(t)\n    rowID, _ := tbl.Insert([]Value{{Type: TypeInteger, Integer: 42}, {Type: TypeText, Text: \"hello\"}})\n    \n    // Get location via B-tree (this is how it will be used)\n    keyBytes := intToBytes(42)\n    location, found, _ := tbl.btree.Search(keyBytes)\n    require.True(t, found)\n    \n    // Test 1: Valid location returns correct row\n    row, err := tbl.GetRowByLocation(location)\n    require.NoError(t, err)\n    assert.Equal(t, rowID, row.ID)\n    assert.Equal(t, int64(42), row.Values[0].Integer)\n    assert.Equal(t, \"hello\", row.Values[1].Text)\n    \n    // Test 2: Invalid page ID\n    badLocation := uint64(999999) \u003c\u003c 32\n    _, err = tbl.GetRowByLocation(badLocation)\n    assert.ErrorContains(t, err, \"page 999999 not found\")\n    \n    // Test 3: Offset past page boundary\n    badOffset := uint64(pageID) \u003c\u003c 32 | uint64(5000)\n    _, err = tbl.GetRowByLocation(badOffset)\n    assert.ErrorContains(t, err, \"out of bounds\")\n}\n```\n\n## Agent Verification Checklist\n\nRun these commands and verify the expected outcomes:\n\n```bash\n# 1. Code compiles\ngo build ./...\n# Expected: exit code 0, no errors\n\n# 2. Unit tests pass\ngo test ./internal/table/... -v -run TestGetRowByLocation\n# Expected: PASS\n\n# 3. Method signature exists\ngrep -n \"func (t \\*Table) GetRowByLocation\" internal/table/table.go\n# Expected: Returns line number with correct signature\n\n# 4. Error handling exists (check for wrapped errors)\ngrep -c \"fmt.Errorf\" internal/table/table.go\n# Expected: At least 3 new error cases added\n```\n\n## Definition of Done\n- [ ] `GetRowByLocation(location uint64) (Row, error)` method exists on Table\n- [ ] All 5 edge cases from table above are handled with specific error messages\n- [ ] `TestGetRowByLocation` test file exists and passes\n- [ ] Integration test: Insert row  B-tree Search  GetRowByLocation  verify row matches\n- [ ] `go test ./internal/table/... -v` shows all tests passing","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-05T05:48:49.071027-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T13:17:11.510595-07:00","closed_at":"2026-01-07T13:17:11.510595-07:00","close_reason":"Implemented by furiosa in commit f6183b8: feat(table): add GetRowByLocation() for index lookups"}
{"id":"claude-db-8p0","title":"Use B-tree for primary key equality lookups","description":"## Problem\nThe executor always does full table scans even for primary key lookups.\n\n## Solution\nUse query planner output to choose between index lookup and full scan.\n\n## Implementation\n\n```go\nfunc (e *Executor) executeSelect(stmt *parser.SelectStatement) (*Result, error) {\n    tbl, exists := e.tables[stmt.From]\n    if !exists {\n        return nil, fmt.Errorf(\"table %s does not exist\", stmt.From)\n    }\n    \n    // Get plan from planner\n    plan, err := e.planner.Plan(stmt)\n    if err != nil {\n        return nil, fmt.Errorf(\"planning failed: %w\", err)\n    }\n    \n    var rows []table.Row\n    \n    switch plan.Type {\n    case planner.PlanIndexScan:\n        // Single-key lookup\n        keyBytes := predicateToKey(plan.IndexPredicates[0])\n        location, found, err := tbl.GetBTree().Search(keyBytes)\n        if err != nil {\n            return nil, err\n        }\n        if found {\n            row, err := tbl.GetRowByLocation(location)\n            if err != nil {\n                return nil, err\n            }\n            // Apply residual predicates\n            if matchesPredicates(row, plan.ResidualPredicates, tbl.Schema) {\n                rows = append(rows, row)\n            }\n        }\n        \n    case planner.PlanIndexRangeScan:\n        // Range scan via iterator\n        start, end := predicatesToBounds(plan.IndexPredicates)\n        iter := tbl.GetBTree().RangeScan(start, end, storage.ScanOptions{})\n        defer iter.Close()\n        \n        for iter.Next() {\n            row, err := tbl.GetRowByLocation(iter.Value())\n            if err != nil {\n                continue // Skip corrupted rows\n            }\n            if matchesPredicates(row, plan.ResidualPredicates, tbl.Schema) {\n                rows = append(rows, row)\n                if plan.Limit != nil \u0026\u0026 len(rows) \u003e= *plan.Limit {\n                    break\n                }\n            }\n        }\n        if iter.Err() != nil {\n            return nil, iter.Err()\n        }\n        \n    case planner.PlanTableScan:\n        // Full scan (existing behavior)\n        allRows, err := tbl.Scan()\n        if err != nil {\n            return nil, err\n        }\n        for _, row := range allRows {\n            if matchesPredicates(row, plan.ResidualPredicates, tbl.Schema) {\n                rows = append(rows, row)\n            }\n        }\n    }\n    \n    // ... rest of SELECT (ORDER BY, LIMIT, projection)\n}\n```\n\n## Files to Modify\n- internal/sql/executor/executor.go\n\n## Edge Cases\n\n| Case | Query | Expected Behavior |\n|------|-------|-------------------|\n| PK equals literal | `WHERE id = 5` | IndexScan, returns 0 or 1 row |\n| PK not found | `WHERE id = 999` (no such row) | IndexScan, returns 0 rows (not error) |\n| PK + other condition | `WHERE id = 5 AND name = 'x'` | IndexScan, then filter by name |\n| PK range | `WHERE id \u003e 10` | IndexRangeScan |\n| Non-PK column | `WHERE name = 'x'` | TableScan with filter |\n| No WHERE | `SELECT * FROM t` | TableScan, no filter |\n| PK with LIMIT | `WHERE id = 5 LIMIT 1` | IndexScan (LIMIT is no-op for single key) |\n| Type mismatch | `WHERE id = 'five'` | Error or TableScan (depends on parser) |\n| Empty table | `WHERE id = 1` on empty table | IndexScan, returns 0 rows |\n\n## Test Scenarios\n\n```go\nfunc TestExecutorUsesPKIndex(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT\")\n    \n    // Insert test data\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'Alice')\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (2, 'Bob')\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (3, 'Charlie')\"))\n    \n    // Test: PK lookup should use index\n    result, err := exec.Execute(parseSQL(\"SELECT * FROM users WHERE id = 2\"))\n    require.NoError(t, err)\n    assert.Equal(t, 1, len(result.Rows))\n    assert.Equal(t, \"Bob\", result.Rows[0][1].Text)\n}\n\nfunc TestExecutorPKNotFound(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT\")\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'Alice')\"))\n    \n    result, err := exec.Execute(parseSQL(\"SELECT * FROM users WHERE id = 999\"))\n    require.NoError(t, err)\n    assert.Equal(t, 0, len(result.Rows)) // Not error, just empty\n}\n\nfunc TestExecutorMixedPredicates(t *testing.T) {\n    exec := setupExecutorWithTable(t, \"users\", \n        \"id INTEGER PRIMARY KEY, name TEXT, age INTEGER\")\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (1, 'Alice', 30)\"))\n    exec.Execute(parseSQL(\"INSERT INTO users VALUES (2, 'Bob', 25)\"))\n    \n    // PK match but residual fails\n    result, err := exec.Execute(parseSQL(\n        \"SELECT * FROM users WHERE id = 1 AND age = 99\"))\n    require.NoError(t, err)\n    assert.Equal(t, 0, len(result.Rows))\n    \n    // PK match and residual passes\n    result, err = exec.Execute(parseSQL(\n        \"SELECT * FROM users WHERE id = 1 AND age = 30\"))\n    require.NoError(t, err)\n    assert.Equal(t, 1, len(result.Rows))\n}\n```\n\n## Performance Verification\n\n```go\nfunc BenchmarkPKLookup(b *testing.B) {\n    exec := setupExecutorWithTable(b, \"users\", \"id INTEGER PRIMARY KEY, name TEXT\")\n    \n    // Insert 10,000 rows\n    for i := 0; i \u003c 10000; i++ {\n        exec.Execute(parseSQL(fmt.Sprintf(\n            \"INSERT INTO users VALUES (%d, 'User%d')\", i, i)))\n    }\n    \n    stmt := parseSQL(\"SELECT * FROM users WHERE id = 5000\")\n    \n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        exec.Execute(stmt)\n    }\n    // Should be O(log n) ~ 14 comparisons, not O(n) = 10000 comparisons\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Executor uses planner\ngrep -n \"planner.Plan\" internal/sql/executor/executor.go\n# Expected: Shows planner being called in executeSelect\n\n# 2. Switch on plan type\ngrep -n \"switch plan.Type\" internal/sql/executor/executor.go\n# Expected: Shows switch statement with PlanIndexScan case\n\n# 3. Uses GetRowByLocation\ngrep -n \"GetRowByLocation\" internal/sql/executor/executor.go\n# Expected: Shows call after B-tree Search\n\n# 4. Tests pass\ngo test ./internal/sql/executor/... -v -run TestExecutor\n# Expected: All PASS\n\n# 5. Benchmark shows improvement\ngo test ./internal/sql/executor/... -bench=BenchmarkPKLookup -benchtime=1s\n# Expected: Fast (microseconds per op, not milliseconds)\n```\n\n## Definition of Done\n- [ ] `executeSelect` calls `planner.Plan()` to get execution plan\n- [ ] Switch statement handles `PlanIndexScan`, `PlanIndexRangeScan`, `PlanTableScan`\n- [ ] `PlanIndexScan` uses `btree.Search()` + `GetRowByLocation()`\n- [ ] Residual predicates applied after row fetch\n- [ ] `TestExecutorUsesPKIndex` passes: correct row returned\n- [ ] `TestExecutorPKNotFound` passes: empty result, no error\n- [ ] `TestExecutorMixedPredicates` passes: residual filtering works\n- [ ] Benchmark shows O(log n) behavior for PK lookups","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-05T05:38:48.750693-07:00","created_by":"cabewaldrop","updated_at":"2026-01-05T05:58:04.780044-07:00","dependencies":[{"issue_id":"claude-db-8p0","depends_on_id":"claude-db-5jc","type":"blocks","created_at":"2026-01-05T05:51:10.608296-07:00","created_by":"cabewaldrop"},{"issue_id":"claude-db-8p0","depends_on_id":"claude-db-goh","type":"blocks","created_at":"2026-01-05T05:51:15.852079-07:00","created_by":"cabewaldrop"}]}
{"id":"claude-db-931","title":"Range scan support for inequality operators","description":"Enable index-backed range scans for inequality operators (\u003e, \u003c, \u003e=, \u003c=, BETWEEN).\n\n## Current State\n- B+ tree leaf nodes are linked (standard B+ tree design)\n- Only equality lookups possible\n- Inequalities always do full scan\n\n## Implementation\n1. Add BTree.RangeSearch(minKey, maxKey) method\n2. Traverse to start leaf, follow links to end\n3. Query planner detects range patterns in WHERE\n4. Generate RangeScan plan instead of FullTableScan\n\n## Patterns to Detect\n- column \u003e value\n- column \u003c value\n- column \u003e= value\n- column \u003c= value\n- column BETWEEN low AND high\n\n## Files\n- internal/storage/btree.go (RangeSearch method)\n- internal/sql/planner/ (range pattern detection)\n\n## Acceptance Criteria\n- WHERE age \u003e 30 uses range scan if index exists\n- BETWEEN uses single range scan\n- Page access proportional to result set, not table size","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-07T12:19:05.994904-07:00","created_by":"mayor","updated_at":"2026-01-07T12:21:33.136725-07:00","closed_at":"2026-01-07T12:21:33.136725-07:00","close_reason":"Superseded by existing claude-db-loe (Implement B-tree range scans) which has iterator design, edge cases, and depends on claude-db-a0f (sibling pointers)","dependencies":[{"issue_id":"claude-db-931","depends_on_id":"claude-db-2tp","type":"blocks","created_at":"2026-01-07T12:19:19.642926-07:00","created_by":"mayor"}]}
{"id":"claude-db-a0f","title":"Add leaf sibling pointers to B-tree for efficient range scans","description":"## Problem\nThe current B+ tree has no sibling pointers between leaf nodes. Range scans must traverse up and down the tree for each leaf, making them O(k log n) instead of O(log n + k).\n\n## Solution\nAdd next/prev sibling pointers to leaf nodes:\n\n```go\ntype BTreeNode struct {\n    pageID      uint32\n    isLeaf      bool\n    numKeys     uint16\n    keys        [][]byte\n    values      []uint64\n    children    []uint32\n    nextLeaf    uint32  // 0 if rightmost leaf\n    prevLeaf    uint32  // 0 if leftmost leaf\n}\n```\n\n## Implementation Details\n\n### Serialization Format Change\n```\nExisting: [isLeaf:1][numKeys:2][numChildren:2][keys...][values/children...]\nNew:      [isLeaf:1][numKeys:2][numChildren:2][nextLeaf:4][prevLeaf:4][keys...][values/children...]\n```\n\n### Split Maintenance\nWhen splitting a leaf node:\n```go\nfunc (bt *BTree) splitChild(...) {\n    // Before: left \u003c-\u003e right_neighbor\n    // After:  left \u003c-\u003e new_sibling \u003c-\u003e right_neighbor\n    \n    sibling.nextLeaf = child.nextLeaf\n    sibling.prevLeaf = child.pageID\n    child.nextLeaf = sibling.pageID\n    \n    // Update right neighbor's prevLeaf\n    if sibling.nextLeaf != 0 {\n        rightNeighbor := loadNode(sibling.nextLeaf)\n        rightNeighbor.prevLeaf = sibling.pageID\n        saveNode(rightNeighbor)\n    }\n}\n```\n\n## Files to Modify\n- internal/storage/btree.go\n\n## Edge Cases\n\n| Case | Scenario | Expected Behavior |\n|------|----------|-------------------|\n| Single-node tree | Root is the only leaf | nextLeaf=0, prevLeaf=0 |\n| First split | Root splits into two leaves | left.nextLeaf=right, right.prevLeaf=left, both ends=0 |\n| Middle split | Split a middle leaf | Chain: ...prev \u003c-\u003e left \u003c-\u003e new \u003c-\u003e next... |\n| Leftmost leaf | First leaf in chain | prevLeaf=0, nextLeaf=second_leaf |\n| Rightmost leaf | Last leaf in chain | prevLeaf=second_to_last, nextLeaf=0 |\n| Load old format | B-tree without sibling fields | nextLeaf=0, prevLeaf=0 (graceful default) |\n\n## Migration Strategy\nFor existing B-trees created before this change:\n```go\nfunc deserializeNode(page *Page) (*BTreeNode, error) {\n    // ... read existing fields ...\n    \n    // Check if sibling fields exist (new format)\n    if buf.Len() \u003e= 8 {\n        binary.Read(buf, binary.LittleEndian, \u0026node.nextLeaf)\n        binary.Read(buf, binary.LittleEndian, \u0026node.prevLeaf)\n    } else {\n        // Old format: default to no siblings\n        node.nextLeaf = 0\n        node.prevLeaf = 0\n    }\n}\n```\n\n## Test Scenarios\n\n```go\nfunc TestSiblingPointersAfterInserts(t *testing.T) {\n    bt := createEmptyBTree(t)\n    \n    // Insert enough keys to cause multiple splits\n    for i := 0; i \u003c 250; i++ {\n        bt.Insert(intToBytes(i), uint64(i))\n    }\n    \n    // Verify sibling chain by traversing from leftmost to rightmost\n    leftmost := findLeftmostLeaf(bt)\n    assert.Equal(t, uint32(0), leftmost.prevLeaf, \"leftmost should have no prev\")\n    \n    visited := 0\n    current := leftmost\n    var lastKey []byte\n    for current != nil {\n        // Verify keys are in order across siblings\n        if lastKey != nil {\n            assert.True(t, bytes.Compare(lastKey, current.keys[0]) \u003c 0,\n                \"keys should be ordered across siblings\")\n        }\n        if len(current.keys) \u003e 0 {\n            lastKey = current.keys[len(current.keys)-1]\n        }\n        \n        visited++\n        if current.nextLeaf == 0 {\n            assert.Equal(t, uint32(0), current.nextLeaf, \"rightmost should have no next\")\n            break\n        }\n        current = loadNode(current.nextLeaf)\n    }\n    \n    // Count should match number of leaves\n    assert.True(t, visited \u003e= 3, \"should have multiple leaves after 250 inserts\")\n}\n\nfunc TestSiblingChainIntegrity(t *testing.T) {\n    bt := createBTreeWith100Keys(t)\n    \n    // Traverse forward and count\n    forwardCount := countLeavesForward(bt)\n    \n    // Traverse backward and count\n    backwardCount := countLeavesBackward(bt)\n    \n    assert.Equal(t, forwardCount, backwardCount, \"forward and backward traversal should match\")\n    \n    // Verify bidirectional links\n    current := findLeftmostLeaf(bt)\n    for current.nextLeaf != 0 {\n        next := loadNode(current.nextLeaf)\n        assert.Equal(t, current.pageID, next.prevLeaf, \n            \"next.prevLeaf should point back to current\")\n        current = next\n    }\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Struct has new fields\ngrep -A5 \"type BTreeNode struct\" internal/storage/btree.go | grep -E \"nextLeaf|prevLeaf\"\n# Expected: Both fields present\n\n# 2. Serialization includes siblings\ngrep -n \"nextLeaf\" internal/storage/btree.go | wc -l\n# Expected: At least 4 occurrences (struct, serialize, deserialize, split)\n\n# 3. Split maintains siblings\ngrep -B2 -A5 \"sibling.nextLeaf\" internal/storage/btree.go\n# Expected: Shows sibling chain maintenance code\n\n# 4. All existing tests still pass\ngo test ./internal/storage/... -v -run TestBTree\n# Expected: All PASS\n\n# 5. New sibling tests pass\ngo test ./internal/storage/... -v -run TestSibling\n# Expected: All PASS\n```\n\n## Definition of Done\n- [ ] `BTreeNode` struct has `nextLeaf uint32` and `prevLeaf uint32` fields\n- [ ] `serializeNode` writes sibling pointers (8 extra bytes)\n- [ ] `deserializeNode` reads sibling pointers (with backward compatibility)\n- [ ] `splitChild` maintains sibling chain (updates 3 nodes: left, new, right_neighbor)\n- [ ] `TestSiblingPointersAfterInserts` passes: forward traversal visits all leaves in order\n- [ ] `TestSiblingChainIntegrity` passes: prev/next pointers are bidirectional\n- [ ] All existing `TestBTree*` tests still pass (no regression)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-05T05:48:54.324651-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T13:17:11.854707-07:00","closed_at":"2026-01-07T13:17:11.854707-07:00","close_reason":"Implemented by slit in commit 0b4d56c: Add leaf sibling pointers to B-tree for efficient range scans"}
{"id":"claude-db-epo","title":"Use PK index for equality lookups","description":"Modify executeSelect() to detect simple primary key equality in WHERE clause and use btree.Search() instead of tbl.Scan().\n\n## Current Behavior\n- Line 299: `rows, err := tbl.Scan()` always does full scan\n- Even `WHERE id = 5` scans entire table\n\n## Implementation\n1. Before calling Scan(), analyze WHERE clause\n2. Detect pattern: BinaryExpression with OpEquals on PK column\n3. If detected, call btree.Search(key) instead\n4. Reduces complexity from O(n) to O(log n)\n\n## Files\n- internal/sql/executor/executor.go (line ~280-299)\n\n## Acceptance Criteria\n- SELECT with PK equality uses index lookup\n- Benchmark shows page access reduction (e.g., 4 pages vs 250 for 1M rows)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T12:19:05.162456-07:00","created_by":"mayor","updated_at":"2026-01-07T12:21:32.610379-07:00","closed_at":"2026-01-07T12:21:32.610379-07:00","close_reason":"Superseded by existing claude-db-8p0 (Use B-tree for primary key equality lookups) which has detailed edge cases, tests, and proper dependencies"}
{"id":"claude-db-goh","title":"Add query planner to analyze WHERE clauses","description":"## Problem\nThere is no query planner - the executor directly executes queries without analyzing optimization opportunities.\n\n## Solution\nCreate a query planner that analyzes WHERE clauses and produces execution plans.\n\n## Design\n\n```go\ntype PlanType int\nconst (\n    PlanTableScan PlanType = iota\n    PlanIndexScan      // Exact key lookup via B-tree Search\n    PlanIndexRangeScan // Range scan via B-tree iterator\n)\n\ntype QueryPlan struct {\n    Type               PlanType\n    Table              string\n    Index              *IndexInfo          // nil for TableScan\n    IndexPredicates    []Predicate         // Pushed to index\n    ResidualPredicates []Predicate         // Applied post-fetch\n    Projection         []int               // Column indices (nil = all)\n    Limit              *int\n    EstimatedRows      float64\n    EstimatedCost      float64\n}\n\ntype Predicate struct {\n    Column   string\n    Operator CompareOp  // Eq, Lt, Gt, Le, Ge, Ne\n    Value    interface{}\n}\n\ntype Planner struct {\n    catalog *catalog.Catalog\n}\n\nfunc (p *Planner) Plan(stmt parser.Statement) (*QueryPlan, error)\nfunc (plan *QueryPlan) Explain() string\n```\n\n## Predicate Classification\n\n**Index-usable (SARGable)**:\n- `column = literal`  IndexScan\n- `column \u003e literal`, `column \u003c literal`, `column \u003e= literal`, `column \u003c= literal`  IndexRangeScan\n- `column BETWEEN a AND b`  IndexRangeScan\n\n**NOT index-usable (residual)**:\n- `column != literal` (requires full scan to find non-matches)\n- `column + 1 = 5` (expression on column)\n- `func(column) = value` (function on column)  \n- `column1 = column2` (no literal)\n- `column LIKE '%foo'` (leading wildcard)\n\n## Files to Create/Modify\n- internal/sql/planner/planner.go (new)\n- internal/sql/planner/predicate.go (new)\n- internal/sql/executor/executor.go\n\n## Edge Cases\n\n| Case | Query | Expected Plan |\n|------|-------|---------------|\n| No WHERE | `SELECT * FROM t` | TableScan, no predicates |\n| PK equality | `SELECT * FROM t WHERE id = 5` | IndexScan on PRIMARY |\n| PK range | `SELECT * FROM t WHERE id \u003e 10` | IndexRangeScan on PRIMARY |\n| Non-indexed column | `SELECT * FROM t WHERE name = 'x'` | TableScan, residual: [name='x'] |\n| AND with PK | `SELECT * FROM t WHERE id = 5 AND name = 'x'` | IndexScan on PRIMARY, residual: [name='x'] |\n| OR condition | `SELECT * FROM t WHERE id = 1 OR id = 2` | TableScan (OR not optimized in v1) |\n| NOT condition | `SELECT * FROM t WHERE NOT id = 5` | TableScan, residual: [NOT id=5] |\n| Expression on column | `SELECT * FROM t WHERE id + 1 = 5` | TableScan, residual: [id+1=5] |\n| NULL check | `SELECT * FROM t WHERE id IS NULL` | TableScan (B-tree doesn't index NULLs) |\n| Empty table | `SELECT * FROM empty_t WHERE id = 1` | IndexScan, EstimatedRows: 0 |\n| Non-existent table | `SELECT * FROM nosuchtable` | Error: \"table nosuchtable does not exist\" |\n\n## Test Scenarios\n\n```go\nfunc TestPlannerSelectPK(t *testing.T) {\n    // Setup: Table 'users' with PK on 'id'\n    planner := setupPlannerWithTable(t, \"users\", []Column{\n        {Name: \"id\", Type: TypeInteger, PrimaryKey: true},\n        {Name: \"name\", Type: TypeText},\n    })\n    \n    stmt := parseSelect(\"SELECT * FROM users WHERE id = 42\")\n    plan, err := planner.Plan(stmt)\n    \n    require.NoError(t, err)\n    assert.Equal(t, PlanIndexScan, plan.Type)\n    assert.Equal(t, \"users\", plan.Table)\n    assert.Equal(t, \"PRIMARY\", plan.Index.Name)\n    assert.Len(t, plan.IndexPredicates, 1)\n    assert.Equal(t, \"id\", plan.IndexPredicates[0].Column)\n    assert.Equal(t, OpEq, plan.IndexPredicates[0].Operator)\n    assert.Equal(t, int64(42), plan.IndexPredicates[0].Value)\n    assert.Empty(t, plan.ResidualPredicates)\n}\n\nfunc TestPlannerMixedPredicates(t *testing.T) {\n    stmt := parseSelect(\"SELECT * FROM users WHERE id = 42 AND name = 'Alice'\")\n    plan, err := planner.Plan(stmt)\n    \n    require.NoError(t, err)\n    assert.Equal(t, PlanIndexScan, plan.Type)\n    assert.Len(t, plan.IndexPredicates, 1)      // id = 42\n    assert.Len(t, plan.ResidualPredicates, 1)   // name = 'Alice'\n}\n\nfunc TestPlannerExplain(t *testing.T) {\n    stmt := parseSelect(\"SELECT * FROM users WHERE id = 42 AND name = 'Alice'\")\n    plan, _ := planner.Plan(stmt)\n    \n    explain := plan.Explain()\n    assert.Contains(t, explain, \"IndexScan\")\n    assert.Contains(t, explain, \"PRIMARY\")\n    assert.Contains(t, explain, \"Index Cond: id = 42\")\n    assert.Contains(t, explain, \"Filter: name = 'Alice'\")\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Package exists and compiles\ngo build ./internal/sql/planner/...\n# Expected: exit code 0\n\n# 2. Planner struct and Plan method exist\ngrep -n \"func (p \\*Planner) Plan\" internal/sql/planner/planner.go\n# Expected: Returns line number\n\n# 3. All tests pass\ngo test ./internal/sql/planner/... -v\n# Expected: PASS for all tests\n\n# 4. Executor uses planner\ngrep -n \"planner.Plan\" internal/sql/executor/executor.go\n# Expected: Returns line number(s) showing planner is called\n```\n\n## Definition of Done\n- [ ] `internal/sql/planner/` package exists with `planner.go` and `predicate.go`\n- [ ] `Planner.Plan()` returns correct `PlanType` for all 10 edge cases in table\n- [ ] `Explain()` output includes: plan type, index name, index conditions, filter conditions\n- [ ] Executor's `executeSelect` calls `planner.Plan()` before choosing access method\n- [ ] `go test ./internal/sql/planner/... -v` passes\n- [ ] At least 5 test cases covering: TableScan, IndexScan, mixed predicates, error cases","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-05T05:39:23.697454-07:00","created_by":"cabewaldrop","updated_at":"2026-01-07T13:17:11.677968-07:00","closed_at":"2026-01-07T13:17:11.677968-07:00","close_reason":"Implemented by nux in commit b70a1d9: Add query planner to analyze WHERE clauses"}
{"id":"claude-db-loe","title":"Implement B-tree range scans","description":"## Problem\nB-tree only supports exact key lookup. Range queries like `WHERE id \u003e 10 AND id \u003c 100` still do full table scans.\n\n## Solution\nAdd iterator-based range scan with early termination support.\n\n```go\ntype ScanOptions struct {\n    StartInclusive bool\n    EndInclusive   bool\n    Limit          int   // 0 = unlimited\n    Reverse        bool  // Descending order\n}\n\ntype BTreeIterator interface {\n    Next() bool           // Advance to next key\n    Key() []byte          // Current key (valid after Next returns true)\n    Value() uint64        // Current value\n    Err() error           // Any error during iteration\n    Close()               // Release resources\n}\n\n// RangeScan returns iterator over [start, end]\n// nil start = scan from beginning, nil end = scan to end\nfunc (bt *BTree) RangeScan(start, end []byte, opts ScanOptions) BTreeIterator\n```\n\n## Implementation\n\n```go\ntype btreeIterator struct {\n    bt           *BTree\n    currentNode  *BTreeNode\n    keyIndex     int\n    endKey       []byte\n    endInclusive bool\n    limit        int\n    count        int\n    exhausted    bool\n    err          error\n}\n\nfunc (it *btreeIterator) Next() bool {\n    if it.exhausted || it.err != nil {\n        return false\n    }\n    if it.limit \u003e 0 \u0026\u0026 it.count \u003e= it.limit {\n        it.exhausted = true\n        return false\n    }\n    \n    // Advance within current node\n    it.keyIndex++\n    \n    // Move to next leaf via sibling pointer\n    if it.keyIndex \u003e= int(it.currentNode.numKeys) {\n        if it.currentNode.nextLeaf == 0 {\n            it.exhausted = true\n            return false\n        }\n        page, err := it.bt.pager.GetPage(it.currentNode.nextLeaf)\n        if err != nil {\n            it.err = err\n            return false\n        }\n        it.currentNode, it.err = deserializeNode(page)\n        if it.err != nil {\n            return false\n        }\n        it.keyIndex = 0\n    }\n    \n    // Check end bound\n    if it.endKey != nil {\n        cmp := bytes.Compare(it.currentNode.keys[it.keyIndex], it.endKey)\n        if cmp \u003e 0 || (cmp == 0 \u0026\u0026 !it.endInclusive) {\n            it.exhausted = true\n            return false\n        }\n    }\n    \n    it.count++\n    return true\n}\n```\n\n## Files to Modify\n- internal/storage/btree.go\n- internal/storage/btree_iterator.go (new)\n\n## Edge Cases\n\n| Case | Start | End | Data | Expected |\n|------|-------|-----|------|----------|\n| Empty range | 50 | 40 | [1..100] | 0 results (start \u003e end) |\n| No matches | 200 | 300 | [1..100] | 0 results |\n| Single result | 50 | 50, inclusive | [1..100] | 1 result: key=50 |\n| Full scan | nil | nil | [1..100] | 100 results |\n| Open start | nil | 10 | [1..100] | 10 results: 1-10 |\n| Open end | 90 | nil | [1..100] | 11 results: 90-100 |\n| Exclusive bounds | 10 | 20, exclusive | [1..100] | 9 results: 11-19 |\n| With Limit | nil | nil, limit=5 | [1..100] | 5 results: 1-5 |\n| Iterator after Close | - | - | - | Next() returns false, Err() nil |\n| Empty tree | nil | nil | [] | 0 results |\n\n## Test Scenarios\n\n```go\nfunc TestRangeScanBasic(t *testing.T) {\n    bt := createBTreeWithKeys(t, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    iter := bt.RangeScan(intToBytes(3), intToBytes(7), ScanOptions{\n        StartInclusive: true,\n        EndInclusive:   true,\n    })\n    defer iter.Close()\n    \n    var results []int\n    for iter.Next() {\n        results = append(results, bytesToInt(iter.Key()))\n    }\n    require.NoError(t, iter.Err())\n    assert.Equal(t, []int{3, 4, 5, 6, 7}, results)\n}\n\nfunc TestRangeScanWithLimit(t *testing.T) {\n    bt := createBTreeWithKeys(t, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    \n    iter := bt.RangeScan(nil, nil, ScanOptions{Limit: 3})\n    defer iter.Close()\n    \n    var results []int\n    for iter.Next() {\n        results = append(results, bytesToInt(iter.Key()))\n    }\n    assert.Equal(t, []int{1, 2, 3}, results)\n}\n\nfunc TestRangeScanEmptyRange(t *testing.T) {\n    bt := createBTreeWithKeys(t, 1, 2, 3, 4, 5)\n    \n    // Start \u003e End\n    iter := bt.RangeScan(intToBytes(10), intToBytes(5), ScanOptions{})\n    assert.False(t, iter.Next())\n    assert.NoError(t, iter.Err())\n}\n\nfunc TestRangeScanUsessSiblingPointers(t *testing.T) {\n    // Insert enough to have multiple leaves\n    bt := createBTreeWithKeys(t, rangeSlice(1, 300)...)\n    \n    iter := bt.RangeScan(intToBytes(50), intToBytes(250), ScanOptions{\n        StartInclusive: true,\n        EndInclusive:   true,\n    })\n    defer iter.Close()\n    \n    count := 0\n    for iter.Next() {\n        count++\n    }\n    assert.Equal(t, 201, count) // 50 to 250 inclusive\n    \n    // Verify we used sibling pointers (not re-traversing)\n    // This would be verified by checking we didn't call Search() multiple times\n    // or by counting page reads\n}\n```\n\n## Performance Requirement\nRange scan of K keys in tree of N total keys must be O(log N + K), not O(K log N).\n\nSimple verification:\n```go\nfunc BenchmarkRangeScan(b *testing.B) {\n    bt := createBTreeWithKeys(b, rangeSlice(1, 100000)...)\n    \n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        iter := bt.RangeScan(intToBytes(1000), intToBytes(2000), ScanOptions{})\n        for iter.Next() {}\n        iter.Close()\n    }\n    // Should be ~same speed regardless of tree size if O(log N + K)\n}\n```\n\n## Agent Verification Checklist\n\n```bash\n# 1. Iterator interface defined\ngrep -n \"type BTreeIterator interface\" internal/storage/btree*.go\n# Expected: Shows interface definition\n\n# 2. RangeScan method exists\ngrep -n \"func (bt \\*BTree) RangeScan\" internal/storage/btree*.go\n# Expected: Shows method signature\n\n# 3. Uses sibling pointers\ngrep -n \"nextLeaf\" internal/storage/btree_iterator.go\n# Expected: Shows sibling pointer usage\n\n# 4. All tests pass\ngo test ./internal/storage/... -v -run TestRangeScan\n# Expected: All PASS\n\n# 5. No regression in existing tests\ngo test ./internal/storage/... -v\n# Expected: All PASS\n```\n\n## Definition of Done\n- [ ] `BTreeIterator` interface exists with `Next()`, `Key()`, `Value()`, `Err()`, `Close()`\n- [ ] `RangeScan(start, end []byte, opts ScanOptions) BTreeIterator` method on BTree\n- [ ] Iterator follows `nextLeaf` pointers (no tree re-traversal per key)\n- [ ] All 10 edge cases from table handled correctly\n- [ ] `TestRangeScanBasic` passes: correct keys in range\n- [ ] `TestRangeScanWithLimit` passes: stops at limit\n- [ ] `TestRangeScanEmptyRange` passes: no results for invalid range\n- [ ] Benchmark shows O(log N + K) behavior (not O(K log N))","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-05T05:39:29.016147-07:00","created_by":"cabewaldrop","updated_at":"2026-01-05T05:57:59.489036-07:00","dependencies":[{"issue_id":"claude-db-loe","depends_on_id":"claude-db-a0f","type":"blocks","created_at":"2026-01-05T05:51:21.108895-07:00","created_by":"cabewaldrop"}]}
{"id":"claude-db-test-xyz","title":"Test force","description":"Test","status":"tombstone","priority":2,"issue_type":"task","created_at":"2026-01-07T14:04:23.235005-07:00","created_by":"mayor","updated_at":"2026-01-07T14:04:47.014839-07:00","close_reason":"Closed","deleted_at":"2026-01-07T14:04:47.014839-07:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
